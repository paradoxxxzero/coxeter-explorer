(function(){"use strict";const{abs:w,cos:A,sin:le,cosh:ae,sinh:ue,acos:he,acosh:fe,min:ge,max:de,round:we,sqrt:T,sign:k,floor:pe,log:xe,PI:E}=Math,i={coxeter:null,vertices:[],edges:[],words:new Map,rules:new Set,edgeHashes:new Set,vertexHashes:new Set,wordsToConsider:[],rootVertices:null,rootVertex:null,gram:null,mirrors:null},W=e=>{Object.assign(i,e)},B=(e,t)=>{const n=e.length-t.length;return n!==0?Math.sign(n):e<=t?-1:1},F=(e,t)=>{const n=e.length-t.length;return n!==0?Math.sign(n):e<=t?1:-1},L=(e,t)=>{const n=new Map,s=Object.keys(e).sort(t);for(let r=0;r<s.length;r++){const o=s[r],[c,l]=[o,e[o]].sort(t);n.has(l)?n.set(l,[c,n.get(l)].sort()[0]):n.set(l,c)}return n},p=(e,t)=>{if(t.length===0||e.size===0)return t;const n=e._re_cache||new RegExp([...e.keys()].join("|"),"g");let s=t;do t=s,s=t.replace(n,r=>e.get(r));while(s!==t);return t},I=(e,t)=>{const n=new Map(e);for(e=[...e.entries()];e.length>0;){S();const[s,r]=e.pop();n.delete(s);const o=p(n,s),c=p(n,r);let l=!0;if(o===c)l=!1;else{const[g,d]=[o,c].sort(t);d!==s&&g!==r&&(n.set(d,g),e.push([d,g]),l=!1)}l&&n.set(s,r)}return n},J=function(e,t){if(t.length===0)return null;const n=Math.max(0,e.length-t.length);for(let s=n;s<e.length;s++)if(e[s]===t[0]&&e.slice(s+1)===t.slice(1,e.length-s))return{prefix:e.slice(0,s),suffix:t.slice(e.length-s)}},K=function(e,t){if(t.length===0)return null;for(let n=0;n<e.length-t.length+1;n++)if(e.slice(n,n+t.length)===t)return{prefix:e.slice(0,n),suffix:e.slice(n+t.length)}},N=(e,t,n,s)=>{const r=J(e,n);if(r)return{s1:r.prefix+s,s2:t+r.suffix};const o=K(e,n);if(o)return{s1:t,s2:o.prefix+s+o.suffix}},P=(e,t)=>{const n=new Map(e),s=[...e.entries()];for(let r=0;r<s.length;r++){S();const[o,c]=s[r];for(let l=0;l<s.length;l++){if(r===l)continue;const[g,d]=s[l],C=N(o,c,g,d);if(C){const a=p(e,C.s1),b=p(e,C.s2);if(a!==b){const[y,O]=[a,b].sort(t);n.set(O,y)}}}}return n},$=(e,t)=>P(I(e,t),t),D=(e,t)=>{if(e.size!==t.size)return!1;const n=e.keys();for(;;){const{done:s,value:r}=n.next();if(s)return!0;if(e.get(r)!==t.get(r))return!1}},G=(e,t)=>{for(e=L(e,t);;){const n=$(e,t);if(D(n,e))return n._re_cache=new RegExp([...n.keys()].join("|"),"g"),n;e=n}};let v,M;const S=()=>{if(performance.now()-v>M)throw new Error("Timeout")},Q=e=>{const t=[50,100,250].map(n=>[n,n]).flat();for(let n=0;n<t.length;n++){M=t[n];try{return v=performance.now(),G(e,n%2?B:F)}catch(s){if(s.message!=="Timeout")throw s}}throw new Error("Timeout")},u=(e,t)=>(w(t%1-.5)<1e-6&&(t*=2),e.repeat(t)),U=(e,t,n,s,r,o,c)=>Q(e===3?{aa:"",bb:"",cc:"",[u("ab",t)]:"",[u("ac",n)]:"",[u("bc",s)]:""}:{aa:"",bb:"",cc:"",dd:"",[u("ab",t)]:"",[u("ac",n)]:"",[u("ad",s)]:"",[u("bc",r)]:"",[u("bd",o)]:"",[u("cd",c)]:""}),X=e=>p(i.rules,e),h={...{p:5,q:2,r:2,s:3,t:2,u:4,x:1,y:0,z:0,w:0,dimensions:4,order:10,segments:32,curve:!0,vertices:!1,edges:!0,light:1.5,thickness:1,projection:"stereographic",controls:"orbit",ambiance:"neon"}},Y=(e,t=!1)=>{Object.assign(h,e),t&&window.history.pushState(null,null,"#"+btoa(JSON.stringify(h)))},f={curvature:0,edges:[],vertices:[],ranges:[]},Z=e=>{Object.assign(f,e)},q=e=>{if(e.length===3)return e[0][0]*e[1][1]*e[2][2]+e[0][1]*e[1][2]*e[2][0]+e[0][2]*e[1][0]*e[2][1]-e[0][2]*e[1][1]*e[2][0]-e[0][1]*e[1][0]*e[2][2]-e[0][0]*e[1][2]*e[2][1];if(e.length===4)return e[0][0]*(e[1][1]*e[2][2]*e[3][3]+e[1][2]*e[2][3]*e[3][1]+e[1][3]*e[2][1]*e[3][2]-e[1][3]*e[2][2]*e[3][1]-e[1][2]*e[2][1]*e[3][3]-e[1][1]*e[2][3]*e[3][2])+e[0][1]*(e[1][0]*e[2][3]*e[3][2]+e[1][2]*e[2][0]*e[3][3]+e[1][3]*e[2][2]*e[3][0]-e[1][3]*e[2][0]*e[3][2]-e[1][2]*e[2][3]*e[3][0]-e[1][0]*e[2][2]*e[3][3])+e[0][2]*(e[1][0]*e[2][1]*e[3][3]+e[1][1]*e[2][3]*e[3][0]+e[1][3]*e[2][0]*e[3][1]-e[1][3]*e[2][1]*e[3][0]-e[1][1]*e[2][0]*e[3][3]-e[1][0]*e[2][3]*e[3][1])+e[0][3]*(e[1][0]*e[2][2]*e[3][1]+e[1][1]*e[2][0]*e[3][2]+e[1][2]*e[2][1]*e[3][0]-e[1][2]*e[2][0]*e[3][1]-e[1][1]*e[2][2]*e[3][0]-e[1][0]*e[2][1]*e[3][2])},m=e=>{const t=q(e);return w(t)<1e-8?0:k(t)},j=(e,t,n=null)=>{const s=n===null?f.curvature:n;let r=0;for(let o=0;o<e.length;o++)r+=e[o]*t[o]*(o===e.length-1&&s||1);return r},ee=(e,t)=>{e=e.slice();const n=2*j(e,t);for(let s=0;s<e.length;s++)e[s]-=n*(f.curvature||s!==e.length-1?t[s]:0);return e},te=e=>{if(e=e.slice(),f.curvature===0){for(let n=0;n<e.length;n++)e[n]/=e[e.length-1];return e}const t=(f.curvature===-1&&k(e[e.length-1])||1)/T(w(j(e,e)));for(let n=0;n<e.length;n++)e[n]*=t;return e},ne=e=>{const t=new Array(h.dimensions).fill().map(()=>new Array(h.dimensions).fill(0));return t[0][0]=1,t[1][0]=e[1][0],t[1][1]=T(1-t[1][0]*t[1][0]),t[2][0]=e[2][0],t[2][1]=(e[2][1]-t[2][0]*t[1][0])/t[1][1],t[2][2]=T(w(1-t[2][0]*t[2][0]-t[2][1]*t[2][1])),h.dimensions===4&&(t[3][0]=e[3][0],t[3][1]=(e[3][1]-t[3][0]*t[1][0])/t[1][1],t[3][2]=(e[3][2]-t[3][0]*t[2][0]-t[3][1]*t[2][1])/t[2][2],t[3][3]=T(w(1-t[3][0]*t[3][0]-t[3][1]*t[3][1]-t[3][2]*t[3][2]))),t[t.length-1][t.length-1]=f.curvature?t[t.length-1][t.length-1]*f.curvature:1,t},H=(e,[t,n,s,r])=>{const o=new Array(h.dimensions);return o[0]=t,o[1]=(n-e[1][0]*o[0])/e[1][1],o[2]=(s-e[2][0]*o[0]-e[2][1]*o[1])/e[2][2],h.dimensions===4&&(o[3]=(r-e[3][0]*o[0]-e[3][1]*o[1]-e[3][2]*o[2])/e[3][3]),o[o.length-1]*=f.curvature||1,te(o)},se=(e,t)=>{for(let n=0;n<e.length;n++)if(w(e[n]-t[n])>1e-8)return!1;return!0},re=e=>{let t=i.rootVertex;for(let n=e.length-1;n>=0;n--)t=ee(t,i.mirrors[e.charCodeAt(n)-97]);return t},x=e=>{let t="";for(let n=0;n<e.length;n++)t+=e[n].toString().slice(0,6),n<e.length-1&&(t+="|");return t},V=({dimensions:e,p:t,q:n,r:s,s:r,t:o,u:c,x:l,y:g,z:d,w:C})=>{const a={coxeter:e===3?[[-1,t,n],[t,-1,s],[n,s,-1]]:e===4?[[-1,t,n,s],[t,-1,r,o],[n,r,-1,c],[s,o,c,-1]]:null,vertices:[],edges:[],words:new Map,edgeHashes:new Set,vertexHashes:new Set,wordsToConsider:[""],rootVertices:null,rootVertex:null};a.gram=a.coxeter.map(b=>b.map(y=>-A(E/y))),Z({curvature:m(a.gram)}),a.mirrors=ne(a.gram),a.rootVertices=a.mirrors.map((b,y)=>H(a.mirrors,new Array(e).fill(0).map((O,ce)=>y===ce?a.curvature||1:0))),a.rootVertex=H(a.mirrors,[l?1:0,g?1:0,d?1:0,C?1:0]),a.words.set("",a.rootVertex),a.rules=U(e,t,n,s,r,o,c),W(a)},R=(e,t,n)=>{const s=String.fromCharCode(97+t);if(e.slice(-1)===s)return;const r=X(e+s);if(i.words.has(r)){const c=i.words.get(r);z(e,r,n,c);return}const o=re(r);return i.words.set(r,o),_(o,e),z(e,r,n,o),r},oe=()=>{let e=[""],t,n=25;_(i.rootVertex,"");do{t=[];for(let s=0;s<i.wordsToConsider.length;s++){const r=i.wordsToConsider[s],o=i.words.get(r);for(let c=0;c<h.dimensions-1;c++){const l=R(r,c,o);l&&t.push(l)}}e.push(...t),i.wordsToConsider=t}while(t.length&&n--);if(n<0)throw new Error("Could not tile fundamental chamber");i.wordsToConsider=e},ie=()=>{let e;e=[];for(let t=0;t<i.wordsToConsider.length;t++){const n=i.wordsToConsider[t],s=i.words.get(n);for(let r=0;r<h.dimensions;r++){const o=R(n,r,s);o&&e.push(o)}}i.wordsToConsider=e};function _(e,t){const n=x(e);i.vertexHashes.has(n)||(i.vertexHashes.add(n),i.vertices.push({vertex:e,word:t}))}function z(e,t,n,s){const r=e.length<t.length||e.length===t.length&&e<t?x(n)+"/"+x(s):x(s)+"/"+x(n);if(!i.edgeHashes.has(r)&&(i.edgeHashes.add(r),!se(n,s))){const o=n.slice(),c=s.slice();return i.edges.push({start:o,end:c,word:e,newWord:t}),!0}}onmessage=({data:{C:e,order:t,uuid:n}})=>{try{if(Y(e),t===0){V(e);try{oe()}catch(s){s.message==="Could not tile fundamental chamber"&&V(e)}}else i.vertices=[],i.edges=[],ie();postMessage({R:f,vertices:i.vertices,edges:i.edges,uuid:n})}catch(s){throw s.uuid=n,s}}})();
