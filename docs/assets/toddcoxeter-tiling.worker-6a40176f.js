(function(){"use strict";const J=(t,e=null,n=1,l=!1)=>{if(e===null&&(e=t,t=0),n===0)throw new Error("Step cannot be zero.");if(e<t&&n>0||e>t&&n<0){if(l)return[];n=-n}return new Array(Math.ceil((e-t)/n)).fill().map((r,s)=>t+s*n)},F=(t,e)=>{let n=0;for(let l=0;l<t.length;l++)n+=t[l]*e[l];return n},K=(t,e)=>{const n=[];for(let l=0;l<t.length;l++)n[l]=t[l]-e[l];return n},O=(t,e)=>{const n=[];for(let l=0;l<t.length;l++)n[l]=t[l]*e;return n},D=(t,e)=>{const n=new Array(t.length);for(let l=0;l<t.length;l++){let r=0;for(let s=0;s<t[0].length;s++)r+=t[l][s]*e[s];n[l]=r}return n},Q=(t,e,n)=>K(t,O(D(Z(n),e),2*F(D(Y(n),t),e))),X=(t,e)=>e.some((n,l)=>n.some((r,s)=>l===s&&r===0))?O(t,1/t[t.length-1]):O(t,-1/x(H(F(D(e,t),t)))),Y=t=>t.map((e,n)=>e.map((l,r)=>n===r&&l===0?1:l)),Z=t=>t.map(e=>e.map(n=>H(n))),R=(t,e,n,l)=>{const r=N/t,s=N/e,o=N/n;return z(N/$(-V(r)*V(o)+M(r)*M(o)*((V(s)-V(l*r)*V(o))/(M(l*r)*M(o)))))},{abs:H,cos:V,sin:M,tan:ge,cosh:he,sinh:de,acos:$,acosh:pe,atan:me,atan2:be,min:we,max:ye,round:z,sqrt:x,sign:_e,ceil:Ae,floor:je,log:ke,exp:Ce,hypot:Pe,pow:Se,PI:N}=Math;function*ee(t,e){if(e<0||t.length<e)return;const n=Array.from(Array(e).keys());for(;;){yield n.map(r=>t[r]);let l=e-1;for(;l>=0&&n[l]>=t.length-e+l;)l--;if(l<0)return;for(let r=n[l]+1;l<e;l++,r++)n[l]=r}}const te=(t,e=2)=>Array.from(ee(t,e)),m=t=>String.fromCharCode(97+t),ne=t=>t.charCodeAt(0)-97,I=(t,e,n,l=[])=>{const r=[];for(let s=0;s<t;s++)l.includes(s)||r.push(m(s).repeat(2));for(let s=1;s<t;s++)for(let o=0;o<s;o++)!l.includes(s)&&!l.includes(o)&&e[s][o]>1&&r.push((m(o)+m(s)).repeat(e[s][o]));if(!l.length&&n&&!n.every(s=>s.every(o=>o===1))){if(t===4&&n[0][1]>1!=n[2][3]>1&&e[0][1]>3&&e[2][3]>3)n[0][1]>1&&r.push("abcdcb".repeat(R(e[0][1],e[1][2],e[0][2],n[0][1]))),n[2][3]>1&&r.push("abcdcb".repeat(R(e[2][3],e[1][2],e[1][3],n[2][3])));else for(let s=1;s<t;s++)for(let o=0;o<s;o++)if(n[o][s]>1){if(o+2<t){const b=R(e[o+1][s+1],e[o][s],e[o][s+1],n[o][s]);r.push((m(o)+m(s)+m(o+2)+m(s)).repeat(b))}if(o-1>=0){const b=R(e[o-1][s-1],e[o][s],e[o-1][s],n[o][s]);r.push((m(o)+m(s)+m(o)+m(o-1)).repeat(b))}}}return r},T=t=>t!==""&&t!=="x",le=t=>isNaN(t)?1:+t,E=(t,e=[])=>t.map((n,l)=>e.includes(l)?"":m(l)).join(""),L=(t,e=[])=>t.map((n,l)=>e.includes(l)||n?"":m(l)).join(""),se=(t,e,n,l)=>{const r=l.map((i,d)=>T(i)?null:d).filter(i=>i),s=I(t,e,n,r),o=E(l,r),b=L(l,r);return{gens:o,subgens:b,rels:s}},re=(t,e,n,l)=>{const r=l.map((i,d)=>T(i)?null:d).filter(i=>i),s=I(t,e,n,r),o=E(l,r),b=[];for(let i=0;i<l.length;i++)if(l[i]){let d=m(i);for(let p=0;p<t;p++)e[i][p]===2&&!l[p]&&(d+=m(p));b.push({gens:o,subgens:d,rels:s,target:m(i)})}return b},oe=(t,e,n,l)=>{const r=l.map((d,p)=>T(d)?null:p).filter(d=>d),s=I(t,e,n,r),o=E(l,r),b=[],i=te(J(t),t-2);for(let d=0;d<i.length;d++){const p=Array.from(new Set(i[d].concat(r))),j=I(t,e,n,p);let y=E(l,p);const u=L(l,p),w=G({gens:y,subgens:u,rels:j,cosets:{normal:[],reverse:[]},rows:[],words:[],limit:1e3}).words;if(w.length>2){let g="";for(let a=0;a<t;a++)p.includes(a)||(g+=m(a));for(let a=0;a<t;a++)if(!l[a]){let f=!0;for(let c=0;c<t;c++)if(!p.includes(c)&&e[c][a]!==2){f=!1;break}f&&(g+=m(a))}b.push({gens:o,subgens:g,rels:s,face:w,double:l.filter((a,f)=>!p.includes(f)).every(a=>!!a)})}}return b},fe=(t,e)=>{if(e.left===e.right)return!1;for(;e.left!==e.right;){const n=t.normal[e.left_coset][e.rel[e.left]];if(n===void 0)break;e.left++,e.left_coset=n}for(;e.left!==e.right;){const n=t.reverse[e.right_target][e.rel[e.right]];if(n===void 0)break;e.right--,e.right_target=n}return e.left===e.right?(t.normal[e.left_coset][e.rel[e.right]]=e.right_target,t.reverse[e.right_target][e.rel[e.right]]=e.left_coset,!0):!1},G=t=>{const{gens:e,subgens:n,rels:l,cosets:r,rows:s,words:o,limit:b}=t,i=e.length,d=l.map(u=>[...u].map(w=>e.indexOf(w))),p=n.split("").map(u=>e.indexOf(u));if(r.normal.length===0){r.normal.push(new Array(i).fill()),r.reverse.push(new Array(i).fill());for(let u=0;u<p.length;u++)r.normal[0][p[u]]=0,r.reverse[0][p[u]]=0}for(s.length===0&&s.push(...d.map(u=>({rel:u,left:0,right:u.length-1,left_coset:0,right_target:0})));s.length&&r.normal.length<b;){for(;;){let g=!1;for(let a=s.length-1;a>=0;a--)fe(r,s[a])&&(g=!0,s.splice(a,1));if(!g)break}const u=r.normal.length;let w=!1;for(let g=0;g<r.normal.length;g++){const a=r.normal[g];for(let f=0;f<a.length;f++){let c=a[f];if(c===void 0){c=r.normal.length,r.normal.push(new Array(i).fill()),r.reverse.push(new Array(i).fill()),r.normal[g][f]=c,r.reverse[c][f]=g,s.push(...d.map(h=>({rel:h,left:0,right:h.length-1,left_coset:u,right_target:u}))),w=!0;break}}if(w)break}}s.length||(t.done=!0),o.length===0&&(o[0]="");let j=!0,y=r.normal.length;for(;ae(r.normal.length,o)&&j&&--y;){j=!1;for(let u=0;u<o.length;u++){if(o[u]===void 0)continue;const w=r.normal[u];for(let g=0;g<w.length;g++){const a=w[g];a===void 0||o[a]!==void 0||(o[a]=o[u]+e[g],j=!0)}}}return j||console.warn("Hole in the cosets"),y===0&&console.warn("Max iterations reached"),{cosets:r,rows:s,words:o}},ae=(t,e)=>{for(let n=0;n<t;n++)if(e[n]===void 0)return!0;return!1};let C=null,q=null,B=null;const ce=(t,e,n,l)=>{const r=()=>({cosets:{normal:[],reverse:[]},rows:[],words:[],done:!1,lastDrawn:0});C={...se(t,e,n,l),...r()},q=re(t,e,n,l).map(s=>({...s,...r()})),B=oe(t,e,n,l).map(s=>({...s,...r(),toRetry:new Set}))},ie=(t,e)=>{const{rootVertex:n,rootNormals:l,metric:r}=t;let s=n;for(let o=0;o<e.length;o++)s=Q(s,l[e.charCodeAt(o)-97],r);return s},P=(t,e)=>{for(let n=0;n<t.length;n++){const l=ne(t[n]),r=C.cosets.normal[e][l];if(r===void 0)return;e=r}return e};onmessage=({data:{order:t,curvature:e,metric:n,coxeter:l,stellation:r,mirrors:s,rootVertices:o,rootNormals:b,dimensions:i,uuid:d}})=>{t===0&&ce(i,l,r,s);let p=X(D(o,s.map(y=>le(y))),n);const j=(t+1)*(e>0?500:100);try{let y=[],u=[],w=[],g=[];if(!C.done){C.limit=j,G(C);for(let a=C.lastDrawn;a<C.words.length;a++){const f=C.words[a];if(f===void 0){y.push({vertex:new Array(i).fill(NaN),word:""});continue}const c=ie({rootVertex:p,rootNormals:b,metric:n},f);y.push({vertex:c,word:f,i:a}),C.lastDrawn=a+1}}for(let a=0;a<q.length;a++){const f=q[a];f.done||(f.limit=j*(e>0?1:e<0?1.5:3),G(f));const c=P(f.target,0);for(let h=f.lastDrawn;h<f.words.length;h++){const _=f.words[h];if(_===void 0)continue;const A=P(_,0),k=P(_,c);if(A===void 0||k===void 0){f.lastDrawn=h;break}u.push({start:A,end:k,word:_}),f.lastDrawn=h+1}}for(let a=0;a<B.length;a++){const f=B[a];f.done||(f.limit=j*(e>0?1:e<0?1.5:2.5),G(f));const c=[];for(let h=0;h<f.face.length;h++)c.push(P(f.face[h],0));for(const h of f.toRetry){const _=f.words[h],A=[];for(let k=0;k<c.length;k++){const S=c[U(k,c.length,f.double)];if(S===void 0)continue;const v=P(_,S);v!==void 0&&A.push(v)}A.length===c.length?(w.push({vertices:A,word:_,len:c.length}),f.toRetry.delete(h)):g.push({vertices:A,word:_,len:c.length})}for(let h=f.lastDrawn;h<f.words.length;h++){let _=!1;const A=f.words[h],k=[];for(let S=0;S<c.length;S++){const v=c[U(S,c.length,f.double)];if(v===void 0){_=!0;continue}const W=P(A,v);if(W===void 0){_=!0;continue}k.push(W)}_?(g.push({vertices:k,word:A,len:c.length}),f.toRetry.add(h)):w.push({vertices:k,word:A,len:c.length}),f.lastDrawn=h+1}}postMessage({vertices:y,edges:u,faces:w,partials:g,order:t,uuid:d})}catch(y){postMessage({error:y.message,uuid:d})}};const U=(t,e,n=!1)=>{if(n){const l=t>0?1-t%2:0;return t>=e/2+l?2*(e-t)-1+l:2*t-l}return t>=e/2?2*(e-t)-1:2*t}})();
