(function(){"use strict";const{abs:B,cos:Qe,sin:Xe,tan:Ye,cosh:Ze,sinh:et,acos:tt,acosh:nt,atan:st,atan2:rt,min:ot,max:it,round:we,sqrt:je,cbrt:lt,sign:ct,ceil:ft,floor:ut,log:gt,exp:dt,hypot:ht,pow:ke,PI:at}=Math,Ve=(...e)=>e.reduce((t,s)=>t+s,0)/e.length,oe=new ArrayBuffer(8),Se=new Float64Array(oe),ie=new Int32Array(oe);function ze(e){return~~e===e?~~e:(Se[0]=e,ie[0]^ie[1])}const le=10**4,Y=e=>{let t="";for(let s=0;s<e.length;s++)t+=ze(we(e[s]*le)/le).toString(),s<e.length-1&&(t+="|");return t},N=e=>String.fromCharCode(97+e),ce=e=>e.charCodeAt(0)-97,G=e=>{const t=e.toUpperCase();return e===t?e.toLowerCase():t},fe=(e,t=null,s=1,n=!1)=>{if(t===null&&(t=e,e=0),s===0)throw new Error("Step cannot be zero.");if(t<e&&s>0||t>e&&s<0){if(n)return[];s=-s}return new Array(Math.ceil((t-e)/s)).fill().map((c,m)=>e+m*s)},H=(e,t)=>e.length!==t.length?!1:e.every((s,n)=>Array.isArray(s)?H(s,t[n]):s===t[n]),ue=e=>e!==""&&e!=="x",Ae=e=>e==="m"||e==="b"||e==="c"||e==="d",Oe=e=>e==="c"||e==="d",y=e=>e==="s"||e==="b"||e==="d",D=(e,t)=>{let s=0;for(let n=0;n<e.length;n++)s+=e[n]*t[n];return s},Ce=(e,t)=>[e[1]*t[2]-e[2]*t[1],e[2]*t[0]-e[0]*t[2],e[0]*t[1]-e[1]*t[0]],T=(e,t)=>{const s=[];for(let n=0;n<e.length;n++)s[n]=e[n]+t[n];return s},Me=(e,t)=>{const s=[];for(let n=0;n<e.length;n++)s[n]=e[n]-t[n];return s},I=(e,t)=>{const s=[];for(let n=0;n<e.length;n++)s[n]=e[n]*t;return s},Z=e=>{const t=[];for(let s=0;s<e[0].length;s++){t.push([]);for(let n=0;n<e.length;n++)t[s].push(e[n][s])}return t},U=(e,t)=>{const s=new Array(e.length);for(let n=0;n<e.length;n++){let c=0;for(let m=0;m<e[0].length;m++)c+=e[n][m]*t[m];s[n]=c}return s},Ee=e=>{const t=new Array(e.length);for(let s=0;s<e.length;s++)t[s]=new Array(e.length).fill(0),t[s][s]=e[s];return t},P=e=>{const t=new Array(e).fill(1);return Ee(t)},ee=(e,t)=>e.filter((s,n)=>!t.includes(n)),ge=(e,t)=>ee(e,t).map(s=>ee(s,t)),_=(e,t,s)=>Me(e,I(U(Fe(s),t),2*D(U(ye(s),e),t))),p=(e,t)=>{if(t.some((n,c)=>n.some((m,u)=>c===u&&m===0)))return e[e.length-1]===0&&(e[e.length-1]=1e-16),I(e,1/e[e.length-1]);let s=D(U(t,e),e);return s===0&&(s=1e-16),I(e,-1/je(B(s)))},We=1,ye=e=>e.map((t,s)=>t.map((n,c)=>s===c&&n===0?We:n)),Fe=e=>e.map(t=>t.map(s=>B(s))),Ie=e=>{const t=[];for(let u=0;u<e.length;u++)for(let h=u+1;h<e.length;h++)e[u][h]!==2&&t.push([u,h]);if(t.length!==e.length-1)return;const s=new Array(e.length).fill(0);if(t.forEach(([u,h])=>{s[u]++,s[h]++}),s.some(u=>u>3)||s.filter(u=>u===1).length!==2)return;const c=[s.indexOf(1)],m=[];for(let u=0;u<e.length-1;u++){const h=c[c.length-1],i=t.findIndex(v=>v.includes(h));let l=t[i];t.splice(i,1),l[0]===h&&l.reverse(),c.push(l[0]),m.push(l.reverse())}return{group:c,pairs:m}},Pe=e=>{const t=new Array(e.length).fill(0);for(let c=0;c<e.length;c++)for(let m=c+1;m<e.length;m++)e[c][m]!==2&&(t[c]++,t[m]++);if(t.filter(c=>c===3).length!==1||t.filter(c=>c===1).length!==e.length-1)return;const s=t.indexOf(3),n=t.map((c,m)=>[m,s]).filter(([c,m])=>c!==m);return{group:[s],pairs:n}},_e=e=>{const t=Ie(e);if(t)return{type:"c",description:"C-Group",...t};const s=Pe(e);return s?{type:"star",description:"Star Group",...s}:{type:"other",description:"Other Group"}},te=(e,t="",s=[])=>{const n=[];for(let c=0;c<e.length;c++){const[m,u]=e[c],h=e.filter((i,l)=>l!==c);if(s.length){const i=s[s.length-1];if(u.some(l=>l===i)){const l=u[1]===i,v=l?m.toUpperCase():m,a=l?[...u].reverse():u;if(a[1]===s[0])return[t+v];h.length&&n.push(...te(h,t+v,s.concat(a.slice(1))))}}else n.push(...te(h,m,u))}return n},Ne=(e,t,s)=>{var l,v;const n=[],c=Object.entries(e),m=c.filter(([a,d])=>d.length===1),u=c.filter(([a,d])=>d.length===2),h=c.filter(([a,d])=>d.length===3),i=Object.fromEntries(m.map(([a,d])=>[d[0],a]));for(let a=0;a<c.length;a++){const[d,r]=c[a];if([1,3].includes(r.length)&&n.push(d.repeat(2)),r.length===2){const o=t[r[0]][r[1]];o>1&&n.push(d.repeat(o))}if(r.length===1){const o=r[0];for(let f=0;f<m.length;f++){const[g,x]=m[f];if(x>o){const w=t[o][x];w>1&&n.push((d+g).repeat(w))}}}if(r.length===3){const o=t[r[0]][r[1]];if(o>1){const f=i[r[1]];f?n.push((d+f).repeat(o%2===0?o/2:o)):console.warn("No conjugate conjugate reflection",d,r)}for(let f=0;f<h.length;f++){const[g,x]=h[f];if(x[1]===r[1]&&x[0]>r[0]){let w=(l=u.find(([b,j])=>j[0]===r[0]&&j[1]===x[0]))==null?void 0:l[0];w||(w=G((v=u.find(([b,j])=>j[1]===r[0]&&j[0]===x[0]))==null?void 0:v[0])),w&&n.push(G(d)+G(w)+g+w)}if(x[0]===r[0]&&x[1]>r[1]){const w=t[r[1]][x[1]];w>1&&n.push((d+g).repeat(w))}}}}if(u.length>1){const a=te(u);n.push(...a.map(d=>d.split("").reverse().join("")))}if(t.length>2&&t.length<6&&s.some((a,d)=>a.some((r,o)=>r>1&&t[d][o]>1))){const a=_e(t),d=[];a.type==="c"?d.push(...Ge(t,s,a.group,a.pairs)):a.type==="star"&&d.push(...Te(t,s,a.group,a.pairs));const r=Object.fromEntries(Object.entries(e).filter(([f,g])=>g.length===1).map(([f,g])=>[g[0],f])),o=Object.entries(e).filter(([f,g])=>g.length===2).map(([f,g])=>[[g,f],[[...g].reverse(),G(f)]]).flat();for(let f=0;f<d.length;f++){const g=d[f];let x="",w=!1;for(let b=0;b<g.length;b++){const j=g[b],S=r[j];if(S)x+=S;else{const V=o.find(([k,z])=>k[0]===j&&b<g.length-1&&k[1]===g[b+1]);if(V)x+=V[1],b++;else{w=!0;break}}}w||n.push(x)}}return n},$=(e,t)=>Array(e).fill(t).flat(),Ge=(e,t,s,n)=>{const c=[];if(!n.filter(([r,o])=>t[r][o]>1).map(([r,o])=>e[r][o]===5))return c;const u=n.map(([r,o])=>e[r][o]);if(u.filter(r=>r!==3&&r!==5).length>(e.length===3?0:1))return c;if(u.filter(r=>r!==3&&r!==5).length===1){const r=u.findIndex(o=>o!==3&&o!==5);if(![0,u.length-1].includes(r))return c}const h=[u,[...u].reverse()],i=n.map(([r,o])=>t[r][o]),l=[i,[...i].reverse()],v=({m:r,s:o})=>{if(r.length!==e.length-1)return!1;for(let f=0;f<h.length;f++){const g=h[f],x=l[f];if(g.every((w,b)=>w===r[b]||r[b]===null)&&x.every((w,b)=>w===o[b]||o[b]===null))return!0}};if(v({m:[null,5,5],s:[null,1,2]})&&(u[i[0]===2?u.length-1:0]=0),[{m:[null,3,5,5],s:[null,1,1,2]},{m:[null,5,5,5],s:[null,1,2,1]},{m:[null,5,3,5],s:[null,1,1,2]}].some(v)||(v({m:[5,5,5,3],s:[1,1,2,1]})&&(u[i[1]===2?u.length-1:0]=0),u.filter(r=>r===3).length>e.length-3))return c;const a=[];let d=[];for(let r=0;r<u.length;r++)u[r]===5&&(d.length?(d.push(r),a.push(d),d=[r]):d.push(r));for(let r=0;r<a.length;r++){const[o,f]=a[r],g=[];for(let x=o;x<f+2;x++)g.push(s[x]);g.push(...g.slice(1,g.length-1).reverse()),c.push($(3,g))}return c},Te=(e,t,s,n)=>{const c=[];if(e.length!==4||!n.filter(([l,v])=>t[l][v]>1).map(([l,v])=>e[l][v]===5))return c;const u=n.map(([l,v])=>e[l][v]);if(u.find(l=>l!==3&&l!==5)||u.filter(l=>l===3).length!==1)return c;const h=n[u.findIndex(l=>l===3)],i=n.filter(([l,v])=>e[l][v]===5);return c.push($(3,[...i[0],...i[1]])),c.push($(2,[...$(3,[i[1][0],...h].reverse()),...$(2,[...i[0]].reverse())])),c},E=(e,t)=>{let s=t,n=0;for(;e.quotientMap[s];)n++,s=e.quotientMap[s];return n>1&&(e.quotientMap[t]=s),s},de=(e,t,s)=>{const n=t,c=[[t,s]];for(;c.length>0;)if([t,s]=c.pop(),t>s&&([t,s]=[s,t]),t=E(e,t),s=E(e,s),t!==s){e.quotientMap[s]=t,e.seen.has(s)&&!e.seen.has(t)&&e.seen.add(t);const m=e.cosets.get(t),u=e.cosets.get(s);e.cosets.delete(s);for(const[h,i]of u)m.has(h)?c.push([m.get(h),i]):m.set(h,i)}return E(e,n)},he=(e,t,s,n)=>{t=E(e,t);const c=e.cosets.get(t);c.has(s)?de(e,c.get(s),n):c.set(s,n)},L=(e,t,s,n)=>{t=E(e,t);let c;const m=e.cosets.get(t);return m.has(s)?(c=E(e,m.get(s)),n!==void 0&&c!==n&&de(e,n,c)):(n?c=n:(c=e.nextVertex++,e.cosets.set(c,new Map),e.unvisited.push(c)),he(e,t,s,c),he(e,c,G(s),t)),c},ae=function(e,t,s){let n=s;for(let c=t.length-1;c>0;c--)n=L(e,n,t[c]);L(e,n,t[0],s)},$e=function(e){if(!e.words){const t=E(e,1);e.words=new Map,e.words.set(t,""),e.currentWords=new Map,e.currentWords.set(t,""),e.lastCoset=t,e.remaining=[t],e.rootVertex&&e.rootNormals&&e.metric&&(e.vertices=new Map,e.vertices.set(t,e.rootVertex))}for(;e.remaining.length>0;){const t=e.remaining[0],s=E(e,t),n=e.cosets.get(s),c=e.words.get(s);if(typeof c>"u"){e.remaining.push(e.remaining.shift());continue}if(n.size<e.gens.length*2)return;const m=[];for(let u=0;u<e.gens.length;u++){const h=e.gens[u],i=E(e,n.get(h));if(!e.words.has(i)){if(e.cosets.get(i).size<e.gens.length*2)return;m.push([h,i])}}e.remaining.shift();for(let u=0;u<m.length;u++){const[h,i]=m[u],l=h+c;if(e.words.set(i,l),e.currentWords.set(i,l),e.lastCoset=i,e.remaining.push(i),e.vertices){let v=e.vertices.get(s);for(let a=0;a<e.transforms[h].length;a++){const d=e.transforms[h][a];v=_(v,e.rootNormals[d],e.metric)}e.vertices.set(i,v)}}}},F=(e,t)=>{let s=E(e,1);for(let n=t.length-1;n>=0;n--){const c=e.cosets.get(s);if(c.size<e.gens.length*2||(s=E(e,c.get(t[n])),e.cosets.get(s).size<e.gens.length*2))return}return s},ve=e=>{if(e.cosets)e.unvisited.splice(0,e.pointer),e.pointer=0;else{e.unvisited=[1],e.pointer=0,e.cosets=new Map([[1,new Map]]),e.nextVertex=2,e.seen=new Set,e.quotientMap={};for(let t=0;t<e.subgens.length;t++)ae(e,e.subgens[t],1)}e.limit=e.limit||1e3,e.done=!1;for(let t=0;t<e.limit;t++){let s=null;for(;e.unvisited.length-e.pointer>0;){const n=e.unvisited[e.pointer++],c=E(e,n);if(!e.seen.has(c)){e.seen.add(c),s=c;break}}if(s===null){e.done=!0;break}for(let n=0;n<e.gens.length;n++)L(e,s,e.gens[n].toUpperCase()),L(e,s,e.gens[n]);for(let n=0;n<e.rels.length;n++)ae(e,e.rels[n],s)}},qe=e=>(ve(e),e.cosets.size),be=e=>(ve(e),$e(e),e),me=(e,t,s)=>{if(s){t%2&&t--;const n=e>0?1-e%2:0;return e>=t/2+n?2*(t-e)-1+n:2*e-n}return e>=t/2?2*(t-e)-1:2*e},Re=(e,t,s)=>{if(t===0)return!0;if(e.length<=t)return!1;const n=new Set;for(let c=0;c<e.length;c++){const m=e[c];if(m)for(let u=0;u<m.length;u++){const h=m[u];for(let i=0;i<s[h].length;i++){const l=N(s[h][i]);n.has(l)||n.add(l)}if(n.size>=t)return!0}}return!1},ne=(e,t,s,n,c,m,u=null,h=null)=>{if(!u){n.every(o=>!o)&&(n=n.map(()=>1));let l="",v=0;const a={};for(let o=0;o<e;o++)if(ue(n[o])){if(!y(n[o])){const f=N(v++);l+=f,a[f]=[o]}for(let f=o+1;f<e;f++)if(ue(n[f])){if(y(n[o])&&y(n[f])){const g=N(v++);l+=g,a[g]=[o,f]}else if(y(n[o])&&!y(n[f])){const g=N(v++);l+=g,a[g]=[o,f,o]}else if(!y(n[o])&&y(n[f])){const g=N(v++);l+=g,a[g]=[f,o,f]}}}const d=Object.entries(a).filter(([o,f])=>f.every(g=>!n[g])).map(([o])=>o).join(""),r=Ne(a,t,s);if(m){const o=m.split(",");for(let f=0;f<o.length;f++){const g=o[f];g&&g.split("").every(x=>l.includes(x))&&r.push(g)}}if(u={new:!0,key:"",dimensions:e,coxeter:t,stellation:s,mirrors:n,gens:l,subgens:d,transforms:a,rels:r,facet:[""],removed:[],children:[]},h=u,h.solved=new Map,n.filter(o=>o).length===1){const o=n.findIndex(f=>f);if(t[o].every((f,g)=>o===g||f===2)){const f=o===e-1?e-2:o+1,[g]=Object.entries(u.transforms).find(([x,w])=>w.includes(f));h.hosotope={gen:g,index:f}}}}const i=[];for(let l=0;l<e;l++){if(u.removed.includes(l))continue;let v=u.gens.split("").filter(g=>!u.transforms[g].includes(l)).join("");const a=[...u.removed,l],d=a.sort().join("-");let r=!1;if(!h.solved.has(d)){r=!0;const g={dimensions:u.dimensions-1,coxeter:ge(h.coxeter,a),stellation:ge(h.stellation,a),mirrors:ee(h.mirrors,a),gens:v,subgens:h.subgens.split("").filter(x=>v.includes(x)).join(""),rels:h.rels.filter(x=>x.toLowerCase().split("").every(w=>v.includes(w))),transforms:Object.fromEntries(Object.entries(u.transforms).filter(([x])=>v.includes(x))),removed:a,key:d,limit:c.curvature>0?5e3:1e3};be(g),g.facet=Array.from(g.words.values()),g.dimensions===1&&(g.coxeter=[[1,2],[2,1]],g.stellation=[[1,1],[1,1]],g.mirrors=[1,0]),g.dimensions===0&&(g.coxeter=[[1,2],[2,1]],g.stellation=[[1,1],[1,1]],g.mirrors=["s",0]),h.solved.set(d,g)}const o=h.solved.get(d),f=h.hosotope&&o.removed.length&&o.removed[0]===h.hosotope.index&&o.removed.every((g,x)=>x===0||g===(o.removed[x-1]+1)%e);if(Re(o.facet,o.dimensions,h.transforms)||f){if(r&&o.dimensions===2){const x=[...o.facet],w=o.gens.split("").every(j=>h.mirrors[h.transforms[j][0]]),b=o.gens.split("").every(j=>h.transforms[j].length===2);for(let j=0;j<x.length;j++)o.facet[j]=x[b?j:me(j,o.facet.length,w)]}const g={new:r,children:[],...o};g.removed.length<e?u.children.push(ne(e,t,s,n,c,m,g,h)):u.children.push(g)}else i.push(o)}if(u.children.length===0&&u.dimensions>0){console.debug("No leaf found, digging deeper",u.gens);for(let l=0;l<i.length;l++){const v=i[l],a={new:!1,children:[],...v};a.removed.length<e?u.children.push(ne(e,t,s,n,c,m,a,h)):u.children.push(a)}}if(u===h&&n.some(l=>y(l))){let l="",v=[];for(let a=1;a<e;a++)if(a===1){const d=[],r=b=>{b.dimensions===1?b.new&&d.push(b):b.children.forEach(r)};r(u);const o=Object.entries(h.transforms).filter(([b,j])=>j.length!==1||n[j[0]]).filter(([b,j])=>j.length!==3||t[j[0]][j[1]]!==2).map(([b])=>b);for(let b=0;b<d.length;b++){const j=d[b];o.includes(j.gens)&&o.splice(o.indexOf(j.gens),1)}const f=v;v=[];const g=P(1).map((b,j)=>b.map((S,V)=>j===V?1:j===V+1||j===V-1?4:2)),x=P(1).map(b=>b.map(()=>1)),w=fe(1).map(()=>"s");for(let b=0;b<o.length;b++){const j=o[b],S={dimensions:1,coxeter:g,stellation:x,mirrors:w};S.gens=j;const V={new:!0,done:!0,key:`se-${j}`,...S,facet:["",j],children:b===0?f:[]};v.push(V)}}else if(a===2){const d=S=>P(2).map((V,k)=>V.map((z,O)=>k===O?1:k===O+1||k===O-1?S:2)),r=S=>P(2).map(V=>V.map(()=>S)),o={},f=Object.entries(h.transforms).filter(([S,V])=>V.length===2),g=Object.entries(h.transforms).filter(([S,V])=>V.length===3);let x="";const w=S=>{S.dimensions===2?S.new&&S.gens.length===1&&(x+=S.gens):S.children.forEach(w)};w(u),l+=x;for(let S=0;S<f.length;S++){const[V,k]=f[S];for(let z=S+1;z<f.length;z++){const[O,C]=f[z];k[k.length-1]===C[C.length-1]&&(o[V+O]={facet:["",V,O]},l+=V+O)}}for(let S=0;S<g.length;S++){const[V,k]=g[S];for(let z=S+1;z<g.length;z++){const[O,C]=g[z];if(k[0]===C[0]&&t[k[1]][C[1]]!==2&&(t[k[1]][k[0]]!==2||t[k[0]][C[1]]!==2)){const W=t[k[1]][C[1]],K=n[C[1]]||t[k[0]][C[1]]!==2,Q=[];for(let X=0;X<W;X++)K&&Q.push(V+(O+V).repeat(W-X)),Q.push((O+V).repeat(X));o[V+O]={facet:Q,snubCoxeter:d(Q.length),snubMirrors:["s",K?1:0]},l+=V+O}}for(let z=0;z<f.length;z++){const[O,C]=f[z];k[0]===C[1]&&(t[k[1]][C[0]]!==2||t[k[1]][C[1]]!==2||n[k[1]])&&(n[k[1]]||t[k[1]][C[0]]!==2&&t[k[1]][C[1]]!==2?o[V+O]={facet:["",V,V+O,O],snubCoxeter:d(4)}:t[k[1]][C[0]]!==2?o[V+O]={facet:["",O,V+O]}:o[V+O]={facet:["",V,O]},l+=V+O)}}const b=v;v=[],Object.keys(o).length||(o[""]={facet:[""]});const j=Object.entries(o);for(let S=0;S<j.length;S++){const[V,{facet:k,snubCoxeter:z,snubStellation:O,snubMirrors:C}]=j[S],W={dimensions:2,coxeter:z||d(3),stellation:O||r(1),mirrors:C||["s","s"]};W.gens=V;const K={new:k.length!==1,done:!0,key:`sf-${V}`,...W,facet:k,children:S===0?b:[]};v.push(K)}}else{const d=P(a).map((w,b)=>w.map((j,S)=>b===S?1:2)),r=P(a).map(w=>w.map(()=>1)),o=fe(a).map(()=>"s"),f=v;v=[];let g=l;const x={new:!0,done:!0,key:`s${a}`,gens:u.gens.split("").filter(w=>!g.includes(w)).join(""),dimensions:a,coxeter:d,stellation:r,mirrors:o,facet:[],children:f};v.push(x)}u.children.push(...v)}return u},q=["vertex","edge","face"],se=(e,t,s)=>(s<0&&(s+=1),s>1&&(s-=1),s<1/6?e+(t-e)*6*s:s<1/2?t:s<2/3?e+(t-e)*(2/3-s)*6:e),M=(e,t,s)=>{let n,c,m;if(t===0)n=c=m=s;else{const u=s<.5?s*(1+t):s+t-s*t,h=2*s-u;n=se(h,u,e+1/3),c=se(h,u,e),m=se(h,u,e-1/3)}return[n,c,m]},J=[[10/360,.56,.91],[0/360,.59,.88],[316/360,.72,.86],[267/360,.84,.81],[343/360,.81,.75],[350/360,.65,.77],[23/360,.92,.75],[41/360,.86,.83],[115/360,.54,.76],[170/360,.57,.73],[189/360,.71,.73],[199/360,.76,.69],[217/360,.92,.76],[232/360,.97,.85]],Be={background:[0,0,0,1],glow:!1,shading:"ads",diffuse:"lambert",specular:!1,shininess:32,opacity:1,ambient:.2,roughness:.85,gouraud:!1,transparency:"oit",color:({word:e})=>M(e.length*.03%1,.75,.7)},He=Object.fromEntries(Object.entries({neon:{background:[0,0,0,1],glow:{exposure:1.75,strength:2,offset:{up:2,down:2},steps:3,pow:2},shading:!1,face:{opacity:.025},transparency:"blend",color:({word:e,dual:t})=>M((e.length*.17-(t?.43:0))%1,.5,.6)},disco:{background:[0,0,0,1],glow:{exposure:1.5,strength:2,offset:{up:2,down:2},steps:4,pow:2},face:{gouraud:!0,diffuse:"fresnel",opacity:.025},transparency:"blend",color:({word:e})=>M(...J[e.length%J.length])},cathedral:{background:[.6,.6,.6,1],glow:{exposure:1.5,strength:2,offset:{up:2,down:2},steps:4,pow:2},shading:!1,face:{opacity:.9},transparency:"oit",color:({word:e,subShape:t,type:s})=>s==="face"?M((t*.23+e.length*.07)%1,1,.58):[0,0,0]},synthwave:{background:[...M(.77,.6,.04),1],glow:{exposure:1.5,strength:3,offset:{up:3,down:3},steps:3,pow:2},shading:!1,face:{opacity:.015},afterImage:.7,transparency:"blend",color:({word:e})=>M((.5-e.length*.05%.5+.65)%1,.4,.6)},colorful:{background:[1,1,1,1],diffuse:"oren-nayar",specular:"cook-torrance",shininess:32,opacity:1,ambient:.2,gouraud:!1,face:{gouraud:!0,opacity:.1,diffuse:"fresnel",specular:!1},transparency:"oit",color:({word:e,dual:t})=>M(e.length*.03%1-(t?.25:0),1,.8)},shiny:{background:[0,0,0,1],diffuse:"lambert",specular:"blinn-phong",shininess:32,opacity:1,ambient:.2,gouraud:!1,face:{gouraud:!0,opacity:.1,diffuse:"fresnel",specular:!1},transparency:"oit",color:({word:e})=>M(-(e.length*.07)%1,1,.8)},shape:{background:[1,1,1,1],transparency:"oit",face:{gouraud:!0,opacity:.2,diffuse:"fresnel"},color:({faceSize:e,type:t,idx:s,size:n})=>t==="face"?M((e-2)*.21%1,1,.8):M(s/n,.75,.5)},subShape:{background:[1,1,1,1],transparency:"oit",face:{gouraud:!0,opacity:.2,diffuse:"fresnel"},color:({subShape:e,type:t})=>t!=="vertex"?M(e*.21%1,1,.8):[1,1,1]},reflection:{background:[1,1,1,1],diffuse:"cel",face:{opacity:.6,gouraud:!1},transparency:"blend",color:({word:e,type:t,dimensions:s,draw:n})=>{const c=e.length?ce(e[e.length-1])/s:0;return M(c%1,1,t==="face"?.6:n.face?0:.8)}},harlequin:{background:[...M(240/360,.23,.09),1],face:{opacity:.6},transparency:"oit",color:({word:e,idx:t,type:s})=>{const n=e.split("").map(m=>ce(m)).reduce((m,u)=>m+u,0),c=[...J[n%J.length]];return t%2&&(c[2]*=.5),M(...c)}},pure:{background:[0,0,0,1],color:({word:e})=>M(e.length*.03%1,.75,.7)},facets:{background:[0,0,0,1],color:({faceIndex:e,faceSize:t})=>M((e||0)/(t||1),.75,.7)},monochrome:{background:[.12,.12,.12,1],diffuse:"reverse",ambient:0,face:{opacity:.1},transparency:"oit",color:()=>[1,1,1]},glass:{background:[0,0,0,1],transparency:"blend",opacity:.2,ambient:0,diffuse:"fresnel",specular:"blinn-phong",face:{shininess:16,diffuse:!1},color:({subShape:e,word:t,type:s})=>s!=="vertex"?M((e*.21+t.length*.03)%1,1,.8):[1,1,1]},plain:{extended:!0,background:[1,1,1,1],glow:!1,shading:!1,color:({word:e,type:t,draw:s})=>M(e.length*.06%1,1,t==="face"?.6:s.face?.05:.5)},plainblack:{extended:!0,background:[1,1,1,1],shading:!1,color:({word:e,type:t})=>t==="face"?new Array(3).fill(1-ke(.9,e.length+1)):[0,0,0]},normals:{extended:!0,background:[1,1,1,1],shading:"normal",color:()=>[0,0,0]},uvs:{extended:!0,background:[1,1,1,1],shading:"uv",color:()=>[0,0,0]}}).map(([e,t])=>[e,{...Be,...t,transparent:{}}])),De=(e,t,s,n)=>{const c=[],m=[],u=e>4?9:e;for(let h=0;h<t.length;h++){const i=t[h];if(!i){c.push(null),m.push(null);continue}const l=[new Float32Array(i.size*3)];for(let d=0;d<h+1;d++)l.push(new Float32Array(i.size*u));let v=0;const a=i.objects.concat(i.partials);for(let d=0;d<a.length;d++){const r=a[d];if(r)for(let o=0;o<r.length;o++){const f=r[o];for(let x=0;x<f.vertices.length;x++){const w=f.vertices[x];for(let b=0;b<w.length;b++)l[x+1][v*u+b]=w[b]}const g=He[s].color({word:f.word,key:f.key,subShape:d%i.objects.length,faceIndex:f.faceIndex,faceSize:f.faceSize,dimensions:e,draw:n,idx:v,size:i.size,type:q[h],dual:!!f.dual});l[0][v*3+0]=g[0],l[0][v*3+1]=g[1],l[0][v*3+2]=g[2],v++}}c.push(l),m.push({start:i.start,size:i.size})}return{infos:m,data:c}},Ue=(e,t,s,n)=>{const c=[],m=[];if(e===0)for(const[u,h]of t.currentWords)c.push({word:h,vertices:[t.vertices.get(u)]}),t.currentWords.delete(u);else if(e===1)for(const[u,h]of t.currentWords){const i={word:h,vertices:[]};for(let l=0;l<t.facet.length;l++){const v=F(n.root,h+t.facet[l]);v&&n.root.vertices.has(v)&&i.vertices.push(n.root.vertices.get(v))}if(n.root.hosotope&&n.root.vertices.size===1&&i.vertices.push(_(i.vertices[0],n.root.rootNormals[n.root.hosotope.index-1],n.root.metric)),!(i.vertices.length<e+1)){if(n.root.hosotope){let l;if(n.root.hosotopeVertex?l=h.split("").reverse().reduce((v,a)=>_(v,n.root.rootNormals[n.root.gens.indexOf(a)],n.root.metric),n.root.hosotopeVertex):(n.root.hosotopeVertex=p(Z(n.root.rootVertices)[n.root.hosotope.index],n.root.metric),l=n.root.hosotopeVertex),c.push({...i,vertices:[i.vertices[0],l]}),c.push({...i,vertices:[l,i.vertices[1]]}),n.root.vertices.size===1){const v=l.map(a=>-a);c.push({...i,vertices:[i.vertices[0],v]}),c.push({...i,vertices:[v,i.vertices[1]]})}}else c.push(i);t.currentWords.delete(u)}}else if(e===2){n.root.hosotopePair=null;for(const[u,h]of t.currentWords){const i=h.length%2?0:1,l=[];for(let r=0;r<t.facet.length;r++){const o=F(n.root,h+t.facet[r]);o&&n.root.vertices.has(o)&&l.push(n.root.vertices.get(o))}if(n.root.hosotope){n.root.vertices.size===1&&l.push(l[0].map(o=>-o));let r;if(n.root.hosotopePair)r=n.root.hosotopePair.map(o=>h.split("").reverse().reduce((f,g)=>_(f,n.root.rootNormals[n.root.gens.indexOf(g)],n.root.metric),o));else{const o=p(Z(n.root.rootVertices)[n.root.hosotope.index],n.root.metric);n.root.hosotopePair=[o,_(o,n.root.rootNormals[n.root.hosotope.index],n.root.metric)],r=n.root.hosotopePair}l.splice(1,0,r[0]),l.push(r[1]),n.root.vertices.size===1&&(l[3]=l[1].map(o=>-o))}if(l.length<e+1)continue;const v=l.length<t.facet.length;if(v||t.currentWords.delete(u),l.length===3&&!l.reduce((r,o)=>T(r,o),new Array(s.dimensions).fill(0)).every(r=>B(r)<1e-12)){i&&([l[2],l[1]]=[l[1],l[2]]);const r={word:h,vertices:l,faceIndex:0,faceSize:3,partial:v};v?m.push(r):c.push(r);continue}let a=new Array(s.dimensions).fill(0);for(let r=0;r<l.length;r++){const o=l[r];a=T(a,o)}a=I(a,1/l.length);const d=[];if(a.every(r=>B(r)<1e-12)){const r=Ce(l[0],l[1]),o=new Array(s.dimensions).fill(0);r.map((f,g)=>o[g]=f),d.push(o),d.push(o.map(f=>-f));for(let f=3;f<s.dimensions;f++){const g=[...o];g[2]=0,g[f]=o[2],d.push(g),d.push(g.map(x=>-x))}}else d.push(a);for(let r=0;r<l.length;r++)for(let o=0;o<d.length;o++){const f={word:h,vertices:[l[(r+i)%l.length],l[(r+(1-i))%l.length],d[o]],faceIndex:r,faceSize:l.length,partial:v};v?m.push(f):c.push(f)}}}return{objects:c,partials:m}},re=(e,t=null)=>{if(!e.length)return t||[];if(!t)return t=e[0],re(e.slice(1),t);const s=t[t.length-1],n=e.find(m=>m[0]===s||m[1]===s);if(!n)return t;const c=e.indexOf(n);return e.splice(c,1),n[0]===s?t.push(n[1]):t.push(n[0]),re(e,t)},pe=(e,t,s,n)=>{const c=[],m=t.children.find(i=>i.key===s.replace("d","")),u=[],h=i=>{i.dimensions===e&&u.push(i.facet),i.children.forEach(h)};h(m),t.children.filter(i=>i.key.includes("s")).forEach(h);for(let i=0;i<u.length;i++){const l=u[i];if(l.length<2)continue;const v=[];for(let d=0;d<l.length;d++){const r=F(n,l[d]);r&&n.vertices.has(r)&&v.push(n.vertices.get(r))}let a=new Array(v[0].length).fill(0);for(let d=0;d<v.length;d++){const r=v[d];a=T(a,r)}a=I(a,1/v.length),c.push(D(a,a))}return Ve(...c)},Le=(e,t,s,n,c,m)=>{var l,v,a;const{space:u}=n.root,h=[],i=[];if(e===0){n.root.dualVertices=n.root.dualVertices||new Map;for(const[d,r]of t.currentWords){const o=[];for(let w=0;w<t.facet.length;w++){const b=F(n.root,r+t.facet[w]);b&&n.root.vertices.has(b)&&o.push(b)}if(o.length<2)continue;const f=o.length<t.facet.length;let g=new Array(s.dimensions).fill(0);for(let w=0;w<o.length;w++){const b=n.root.vertices.get(o[w]);g=T(g,b)}if(g=p(g,u.metric),u.curvature){let w=0;if(c>=0){let b=1;c>0&&c<s.dimensions-1&&(t.midradius||(t.midradius=pe(c,s,m,n.root)),b=t.midradius);const j=U(u.metric,g);for(let S=0;S<o.length;S++){const V=n.root.vertices.get(o[S]);w+=D(j,V)}w/=b*o.length,c===s.dimensions-1&&(w=1/w)}else w=1;g=I(g,u.curvature/w)}const x={word:r,vertices:[g],dual:!0,partial:f};n.root.dualVertices.set(`${m}#${r}`,{vertex:g,facet:o,partial:f}),f?i.push(x):(h.push(x),t.currentWords.delete(d))}}else if(e===1){if(!((l=n.root.dualVertices)!=null&&l.size))return{objects:h,partials:i};n.root.dualEdges=n.root.dualEdges||new Map;for(const[d,r]of t.currentWords){const o=[];for(let b=0;b<t.facet.length;b++){const j=F(n.root,r+t.facet[b]);j&&n.root.vertices.has(j)&&o.push(j)}if(!o.length)continue;let f=o.length<t.facet.length;const g=[],x=[];for(const[b,{vertex:j,facet:S,partial:V}]of n.root.dualVertices.entries())if(o.every(k=>S.includes(k))&&(g.push(j),x.push(b)),f=f||V,g.length===2)break;if(g.length!==2)continue;const w={word:r,vertices:g,dual:!0,partial:f};n.root.dualEdges.set(`${m}#${r}`,{edge:x,partial:f}),f?i.push(w):(h.push(w),t.currentWords.delete(d))}}else if(e===2){if(!((v=n.root.dualVertices)!=null&&v.size)||!((a=n.root.dualEdges)!=null&&a.size))return{objects:h,partials:i};for(const[d,r]of t.currentWords){const o=[];for(let k=0;k<t.facet.length;k++){const z=F(n.root,r+t.facet[k]);z&&n.root.vertices.has(z)&&o.push(z)}if(o.length<t.facet.length)continue;let f=!1;const g={},x=[];for(const[k,{vertex:z,facet:O,partial:C}]of n.root.dualVertices.entries())(o.every(W=>O.includes(W))||s.dimensions===2)&&(g[k]=z,x.push(k),f=f||C);if(x.length<3)continue;const w=[];for(const{edge:k,partial:z}of n.root.dualEdges.values())x.includes(k[0])&&x.includes(k[1])&&(f=f||z,w.push([...k]));if(w.length<3)continue;const b=[],j=re(w);if(j.length<4)continue;j[0]===j[j.length-1]&&j.pop();for(let k=0;k<j.length;k++){const z=j[k];b.push(g[z])}if(b.length===3){const k={word:r,vertices:b,dual:!0,partial:f};f?i.push(k):(h.push(k),t.currentWords.delete(d));continue}const S=r.length%2?0:1;let V=new Array(s.dimensions).fill(0);for(let k=0;k<b.length;k++){const z=b[k];V=T(V,z)}V=I(V,1/b.length);for(let k=0;k<b.length;k++){const z={word:r,vertices:[b[(k+S)%b.length],b[(k+(1-S))%b.length],V],dual:!0,faceIndex:k,faceSize:b.length,partial:f};f?i.push(z):(h.push(z),t.currentWords.delete(d))}}}return{objects:h,partials:i}},Je=(e,t,s)=>{const n=[],c=[],m=[];for(const[u,h]of e.currentWords){let i;if(h===""){const l=Z(s.rootVertices);e.fundamentalVertices=new Map,i=l.map(v=>p(v,s.metric)),e.hashes={vertex:new Set,edge:new Set,face:new Set},e.fundamentalVertices.set("",i)}else{i=[...e.fundamentalVertices.get(h.slice(1))];const l=e.gens.indexOf(h[0]);for(let v=0;v<i.length;v++)i[v]=_(i[v],s.rootNormals[l],s.metric)}for(let l=0;l<i.length;l++){const v=Y(i[l]);e.hashes.vertex.has(v)||(n.push({word:h,cosetId:u,vertices:[i[l]]}),e.hashes.vertex.add(v));for(let a=l+1;a<i.length;a++){const d=[i[l],i[a]].sort((r,o)=>{for(let f=0;f<r.length;f++){if(r[f]<o[f])return-1;if(r[f]>o[f])return 1}return 0}).map(r=>Y(r)).join("-");e.hashes.edge.has(d)||(c.push({word:h,cosetId:u,vertices:[i[l],i[a]]}),e.hashes.edge.add(d));for(let r=a+1;r<i.length;r++){const o=[i[l],i[a],i[r]].sort((f,g)=>{for(let x=0;x<f.length;x++){if(f[x]<g[x])return-1;if(f[x]>g[x])return 1}return 0}).map(f=>Y(f)).join("-");e.hashes.face.has(o)||(m.push({word:h,cosetId:u,vertices:[i[l],i[a],i[r]]}),e.hashes.face.add(o))}}e.fundamentalVertices.set(h,i)}e.currentWords.delete(u)}return[n,c,m]},Ke=(e,t,s,n,c,m,u,h,i)=>{u.root.lasts||(u.root.lasts=new Array(3).fill(0));const l=[];if(c){const v=Je(u.root,e,s);for(let a=0;a<v.length;a++)n[q[a]]?(l.push({start:u.root.lasts[a],size:v[a].length,objects:[v[a]],partials:[]}),u.root.lasts[a]+=v[a].length):l.push(null)}else for(let v=0;v<3;v++){if(!u[v]||!m&&!n[q[v]]){l.push(null);continue}const a={start:u.root.lasts[v],size:0,objects:[],partials:[]};for(let d=0;d<u[v].detail.length;d++){const r=u[v].detail[d],o=t.get(r.key);if(!r.dual&&h.includes(r.key)||!o.compute||!o.currentWords.size){a.objects.push(null),a.partials.push(null);continue}const{objects:f,partials:g}=r.dual?Le(v,o,e,u,i,r.key):Ue(v,o,e,u);!n[q[v]]||h.includes(r.key)||(a.objects.push(f),a.size+=f.length+g.length,u.root.lasts[v]+=f.length,a.partials.push(g))}l.push(a)}return l},xe=(e,t,s,n,c,m,u,h,i=[])=>{i.done=!0;let l=!0;for(const d of s.values())if(d.compute&&!d.done){l=!1;break}const v=(d,r,o)=>{if(r.done===!1||r.facet.length===0)return r.gens.includes(d);const f=[],g=[];for(const x of r.facet){const w=F(o,x);if(!w)return null;const b=F(o,d+x);if(!b)return null;f.push(w),g.push(b)}return f.sort((x,w)=>x-w),g.sort((x,w)=>x-w),f.every((x,w)=>x===g[w])},a=d=>{var x;const r=u||m?t.dimensions-d.dimensions-1:d.dimensions;d.children.forEach(a);const o=h[r],f=q[r],g=`${u?"d":m?"f":""}${d.key}`;if(d!=null&&d.new){i[r]||(i[r]={dimensions:r,processing:c[f]?0:void 0,count:0,detail:[],aggregated:[],done:!0});const w=n.eigens.values;if(!s.has(g)){let V="";if(d.dimensions===0)V=t.subgens;else for(let z=0;z<t.gens.length;z++){const O=v(t.gens[z],d,i.root);if(O===null)return;O&&(V+=t.gens[z])}if((x=i.root)!=null&&x.hosotope){if(d.dimensions===1)V=V.replace(i.root.hosotope.gen,"");else if(d.dimensions===2){let z=i.root.coxeter[i.root.hosotope.index].findIndex((C,W)=>W!==i.root.hosotope.index&&C!==2);z<0&&(z=i.root.hosotope.index<i.root.dimensions-1?i.root.hosotope.index+1:0);const O=Object.entries(i.root.transforms).find(([C,W])=>W.includes(z))[0];V=V.replace(O,i.root.hosotope.gen)}}const k={...t,key:g,subgens:V,facet:d.facet,subdimensions:r,mirrors:d.mirrors,compute:o,space:n,...d.dimensions===0&&!m?{rootVertex:n.rootVertex,rootNormals:n.rootNormals,rootVertices:n.rootVertices,metric:n.metric}:{}};s.set(g,k)}const b=s.get(g);d.dimensions===0&&(i.root=b),b.done||(b.limit=o?e:l?1e3:1,f==="edge"&&n.curvature<=0&&(b.limit*=1.75),o?(be(b),w.some(V=>V<=0)?b.count=1/0:b.count=b.cosets.size):w.some(V=>V<=0)?(b.count=1/0,b.done=!0):b.limit&&(b.count=qe(b)));const j=m?d.mirrors.map(()=>0):d.mirrors;i[r].detail.push({key:g,coxeter:d.coxeter,stellation:d.stellation,mirrors:j,dual:u,fundamental:m,count:b.count,done:b.done});const S=i[r].aggregated.find(({coxeter:V,stellation:k,mirrors:z})=>H(V,d.coxeter)&&H(k,d.stellation)&&H(z,j));S?(S.done=S.done&&b.done,S.count+=b.count,S.key+=","+g):i[r].aggregated.push({key:g,coxeter:d.coxeter,stellation:d.stellation,mirrors:j,count:b.count,done:b.done}),c[f]&&b.words&&(i[r].processing+=b.words.size),i[r].count+=b.count,i[r].done=i[r].done&&b.done,i[r].dual=u,i[r].fundamental=m,i.done=i.done&&b.done}};return t.children.forEach(a),i.size=m?i.root.words.size:i.root.vertices.size,i};let R,A;onmessage=({data:{first:e,space:t,dimensions:s,coxeter:n,stellation:c,mirrors:m,ambiance:u,draw:h,batch:i,hidden:l,reciprocation:v,extrarels:a}})=>{try{e&&(R=new Map,A=ne(s,n,c,m,t,a),self.shape=A);const d=m.every(j=>!j),r=m.some(j=>Ae(j)),o=m.some(j=>Oe(j)),f=d?{[s-1]:!0}:r?{[s-1]:!0,[s-2]:h.edge||h.face,[s-3]:h.face,0:!0}:{0:!0,1:h.edge,2:h.face},g=xe(i,A,R,t,h,d,r&&!o,f);if(o&&xe(i,A,R,t,h,d,r,f,g),A.dimensions===2){A.currentWords=new Map([[1,""]]);const j=A.gens.split("").every(k=>A.mirrors[A.transforms[k][0]]),S=A.gens.split("").every(k=>A.transforms[k].length===2),V=Array.from(g.root.words.values());A.facet=new Array(V.length);for(let k=0;k<V.length;k++)A.facet[k]=V[S?k:me(k,A.facet.length,j)];A.done=!0,R.set("f",{...A,subgens:A.subgens,facet:A.facet,subdimensions:A.dimensions,mirrors:A.mirrors,compute:!0}),g[2]={dimensions:2,processing:1,count:0,detail:[{key:"f",coxeter:A.coxeter,stellation:A.stellation,mirrors:A.mirrors,dual:r,count:0,done:!0}],aggregated:[{key:"f",coxeter:A.coxeter,stellation:A.stellation,mirrors:A.mirrors,dual:r,count:0,done:!0}],done:!0}}const x=Ke(A,R,t,h,d,r,g,l,v),{infos:w,data:b}=De(A.dimensions,x,u,h);g.root={gens:A.gens,subgens:A.subgens,rels:A.rels},postMessage({polytope:g,infos:w,data:b},b.flat(1).filter(j=>j).map(j=>j.buffer))}catch(d){postMessage({error:d.message})}}})();
