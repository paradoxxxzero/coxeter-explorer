(function(){"use strict";const{abs:h,cos:R,sin:fe,cosh:he,sinh:ae,acos:ue,acosh:ge,min:de,max:we,round:b,sqrt:u,sign:x,floor:pe,log:xe,PI:z}=Math,c={coxeter:null,vertices:[],edges:[],words:new Map,rules:new Set,edgeHashes:new Set,vertexHashes:new Set,wordsToConsider:[],rootVertices:null,rootVertex:null,gram:null,mirrors:null},E=e=>{Object.assign(c,e)},F=(e,r)=>{const n=e.length-r.length;return n!==0?Math.sign(n):e<=r?-1:1},I=(e,r)=>{const n=e.length-r.length;return n!==0?Math.sign(n):e<=r?1:-1},O=(e,r)=>{const n=new Map,t=Object.keys(e).sort(r);for(let o=0;o<t.length;o++){const l=t[o],[s,i]=[l,e[l]].sort(r);n.has(i)?n.set(i,[s,n.get(i)].sort()[0]):n.set(i,s)}return n},g=(e,r)=>{if(r.length===0||e.size===0)return r;const n=e._re_cache||new RegExp([...e.keys()].join("|"),"g");let t=r;do r=t,t=r.replace(n,o=>e.get(o));while(t!==r);return r},q=(e,r)=>{const n=new Map(e);for(e=[...e.entries()];e.length>0;){k();const[t,o]=e.pop();n.delete(t);const l=g(n,t),s=g(n,o);let i=!0;if(l===s)i=!1;else{const[f,a]=[l,s].sort(r);a!==t&&f!==o&&(n.set(a,f),e.push([a,f]),i=!1)}i&&n.set(t,o)}return n},L=function(e,r){if(r.length===0)return null;const n=Math.max(0,e.length-r.length);for(let t=n;t<e.length;t++)if(e[t]===r[0]&&e.slice(t+1)===r.slice(1,e.length-t))return{prefix:e.slice(0,t),suffix:r.slice(e.length-t)}},K=function(e,r){if(r.length===0)return null;for(let n=0;n<e.length-r.length+1;n++)if(e.slice(n,n+r.length)===r)return{prefix:e.slice(0,n),suffix:e.slice(n+r.length)}},N=(e,r,n,t)=>{const o=L(e,n);if(o)return{s1:o.prefix+t,s2:r+o.suffix};const l=K(e,n);if(l)return{s1:r,s2:l.prefix+t+l.suffix}},P=(e,r)=>{const n=new Map(e),t=[...e.entries()];for(let o=0;o<t.length;o++){k();const[l,s]=t[o];for(let i=0;i<t.length;i++){if(o===i)continue;const[f,a]=t[i],d=N(l,s,f,a);if(d){const v=g(e,d.s1),_=g(e,d.s2);if(v!==_){const[ie,ce]=[v,_].sort(r);n.set(ce,ie)}}}}return n},$=(e,r)=>P(q(e,r),r),G=(e,r)=>{if(e.size!==r.size)return!1;const n=e.keys();for(;;){const{done:t,value:o}=n.next();if(t)return!0;if(e.get(o)!==r.get(o))return!1}},J=(e,r)=>{for(e=O(e,r);;){const n=$(e,r);if(G(n,e))return n._re_cache=new RegExp([...n.keys()].join("|"),"g"),n;e=n}};let C,y;const k=()=>{if(performance.now()-C>y)throw new Error("Timeout")},Q=e=>{const r=[50,100,250,500].map(n=>[n,n]).flat();for(let n=0;n<r.length;n++){y=r[n];try{return C=performance.now(),J(e,n%2?F:I)}catch(t){if(t.message!=="Timeout")throw t}}throw new Error("Timeout")},w=e=>String.fromCharCode(97+e),U=(e,r)=>{const n={};for(let t=0;t<e;t++)n[w(t).repeat(2)]="";for(let t=1;t<e;t++)for(let o=0;o<t;o++)n[(w(o)+w(t)).repeat(r[t][o])]="";return Q(n)},X=e=>g(c.rules,e),m=e=>{if(e.length===1)return e[0][0];let r=0;for(let n=0;n<e.length;n++){const t=new Array(e.length-1).fill().map(()=>new Array(e.length-1).fill(0));for(let l=1;l<e.length;l++)for(let s=0;s<e.length;s++)s<n?t[l-1][s]=e[l][s]:s>n&&(t[l-1][s-1]=e[l][s]);const o=n%2===0?1:-1;r+=e[0][n]*o*m(t)}return r},Y=e=>{const r=m(e);return h(r)<1e-8?0:x(r)},T=(e,r,n)=>{let t=0;for(let o=0;o<e.length;o++)t+=e[o]*r[o]*(o===e.length-1&&n||1);return t},Z=(e,r,n)=>{e=e.slice();const t=2*T(e,r,n);for(let o=0;o<e.length;o++)e[o]-=t*(n||o!==e.length-1?r[o]:0);return e},D=(e,r)=>{if(e=e.slice(),r===0){for(let t=0;t<e.length;t++)e[t]/=e[e.length-1];return e}const n=(r===-1&&x(e[e.length-1])||1)/u(h(T(e,e,r)));for(let t=0;t<e.length;t++)e[t]*=n;return e},ee=(e,r)=>{const n=e[0].length,t=new Array(n).fill().map(()=>new Array(n).fill(0));return t[0][0]=1,t[1][0]=e[1][0],t[1][1]=u(h(1-t[1][0]*t[1][0])),t[2][0]=e[2][0],t[2][1]=(e[2][1]-t[2][0]*t[1][0])/t[1][1],t[2][2]=u(h(1-t[2][0]*t[2][0]-t[2][1]*t[2][1])),n>=4&&(t[3][0]=e[3][0],t[3][1]=(e[3][1]-t[3][0]*t[1][0])/t[1][1],t[3][2]=(e[3][2]-t[3][0]*t[2][0]-t[3][1]*t[2][1])/t[2][2],t[3][3]=u(h(1-t[3][0]*t[3][0]-t[3][1]*t[3][1]-t[3][2]*t[3][2]))),n>=5&&(t[4][0]=e[4][0],t[4][1]=(e[4][1]-t[4][0]*t[1][0])/t[1][1],t[4][2]=(e[4][2]-t[4][0]*t[2][0]-t[4][1]*t[2][1])/t[2][2],t[4][3]=(e[4][3]-t[4][0]*t[3][0]-t[4][1]*t[3][1]-t[4][2]*t[3][2])/t[3][3],t[4][4]=u(h(1-t[4][0]*t[4][0]-t[4][1]*t[4][1]-t[4][2]*t[4][2]-t[4][3]*t[4][3]))),t[t.length-1][t.length-1]=r?t[t.length-1][t.length-1]*r:1,t},M=(e,r,n)=>{const t=r.length,o=new Array(t);return o[0]=r[0],o[1]=(r[1]-e[1][0]*o[0])/e[1][1],o[2]=(r[2]-e[2][0]*o[0]-e[2][1]*o[1])/e[2][2],t>=4&&(o[3]=(r[3]-e[3][0]*o[0]-e[3][1]*o[1]-e[3][2]*o[2])/e[3][3]),t>=5&&(o[4]=(r[4]-e[4][0]*o[0]-e[4][1]*o[1]-e[4][2]*o[2]-e[4][3]*o[3])/e[4][4]),o[o.length-1]*=n||1,D(o,n)},te=(e,r)=>{for(let n=0;n<e.length;n++)if(h(e[n]-r[n])>1e-8)return!1;return!0},ne=e=>{let r=c.rootVertex;for(let n=e.length-1;n>=0;n--)r=Z(r,c.mirrors[e.charCodeAt(n)-97],c.curvature);return r},A=new ArrayBuffer(8),re=new Float64Array(A),H=new Int32Array(A);function oe(e){return~~e===e?~~e:(re[0]=e,H[0]^H[1])}const j=10**4,p=e=>{let r="";for(let n=0;n<e.length;n++)r+=oe(b(e[n]*j)/j).toString(),n<e.length-1&&(r+="|");return r},S=(e,r,n,t,o)=>{const l=U(e,n);if(r)for(let i=0;i<e;i++)for(let f=0;f<e;f++)n[i][f]/=t[i][f];const s={coxeter:n,vertices:[],edges:[],words:new Map,edgeHashes:new Set,vertexHashes:new Set,wordsToConsider:[""],rootVertices:null,rootVertex:null,rules:l};s.gram=s.coxeter.map(i=>i.map(f=>-R(z/f))),s.curvature=Y(s.gram),s.mirrors=ee(s.gram,s.curvature),s.rootVertices=s.mirrors.map((i,f)=>M(s.mirrors,new Array(e).fill(0).map((a,d)=>f===d?s.curvature||1:0),s.curvature)),s.rootVertex=M(s.mirrors,o,s.curvature),s.words.set("",s.rootVertex),E(s)},V=(e,r,n)=>{const t=String.fromCharCode(97+r);if(e.slice(-1)===t)return;const o=X(e+t);if(c.words.has(o)){const s=c.words.get(o);B(e,o,n,s);return}const l=ne(o);return c.words.set(o,l),W(l,e),B(e,o,n,l),o},se=()=>{let e=[""],r,n=25;const t=c.rootVertex.length;W(c.rootVertex,"");do{r=[];for(let o=0;o<c.wordsToConsider.length;o++){const l=c.wordsToConsider[o],s=c.words.get(l);for(let i=0;i<t-1;i++){const f=V(l,i,s);f&&r.push(f)}}e.push(...r),c.wordsToConsider=r}while(r.length&&n--);if(n<0)throw new Error("Could not tile fundamental chamber");c.wordsToConsider=e},le=()=>{let e;e=[];for(let r=0;r<c.wordsToConsider.length;r++){const n=c.wordsToConsider[r],t=c.words.get(n);for(let o=0;o<t.length;o++){const l=V(n,o,t);l&&e.push(l)}}c.wordsToConsider=e};function W(e,r){const n=p(e);c.vertexHashes.has(n)||(c.vertexHashes.add(n),c.vertices.push({vertex:e,word:r}))}function B(e,r,n,t){const o=p(n),l=p(t);if(o===l)return;const s=[o,l].sort().join("/");if(!c.edgeHashes.has(s)&&(c.edgeHashes.add(s),!te(n,t))){const i=n.slice(),f=t.slice();return c.edges.push({start:i,end:f,word:e}),!0}}onmessage=({data:{dimensions:e,coxeter:r,coxeterDiv:n,stellation:t,mirrors:o,currentOrder:l,uuid:s}})=>{try{if(l===0){S(e,t,r,n,o);try{se()}catch(i){i.message==="Could not tile fundamental chamber"&&S(e,t,r,n,o)}}else c.vertices=[],c.edges=[],le();postMessage({curvature:c.curvature,vertices:c.vertices,edges:c.edges,currentOrder:l+1,uuid:s})}catch(i){postMessage({error:i.message,uuid:s})}}})();
