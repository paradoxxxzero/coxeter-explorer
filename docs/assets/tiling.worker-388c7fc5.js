(function(){"use strict";const{abs:W,cos:S,sin:V,cosh:z,sinh:L,acos:P,acosh:T,tan:_,min:q,max:N,round:k,sqrt:R,sign:$,floor:v,log:D,exp:G,PI:J}=Math,b=(e,n)=>{if(n.length===0||e.size===0)return n;const r=e._re_cache||new RegExp([...e.keys()].join("|"),"g");let o=n;do n=o,o=n.replace(r,t=>e.get(t));while(o!==n);return n},y=(e,n)=>b(e,n),A=(e,n,r)=>{let o=0;for(let t=0;t<e.length;t++)o+=e[t]*n[t]*(t===e.length-1&&r||1);return o},H=(e,n,r)=>{e=e.slice();const o=2*A(e,n,r);for(let t=0;t<e.length;t++)e[t]-=o*(r||t!==e.length-1?n[t]:0);return e},j=(e,n)=>{for(let r=0;r<e.length;r++)if(W(e[r]-n[r])>1e-8)return!1;return!0},f=new ArrayBuffer(8),B=new Float64Array(f),d=new Int32Array(f);function E(e){return~~e===e?~~e:(B[0]=e,d[0]^d[1])}const a=10**4,u=e=>{let n="";for(let r=0;r<e.length;r++)n+=E(k(e[r]*a)/a).toString(),r<e.length-1&&(n+="|");return n},F=(e,n)=>{const{rootVertex:r,mirrorsPlanes:o,curvature:t}=e;let s=r;for(let i=n.length-1;i>=0;i--)s=H(s,o[n.charCodeAt(i)-97],t);return s};function m(e,n,r){const{vertexHashes:o}=e,t=u(n);if(!o.has(t))return o.add(t),e.vertices.push({vertex:n,word:r}),!0}function x(e,n,r,o){const{edgeHashes:t}=e,s=u(r),i=u(o);if(s===i)return;const c=[s,i].sort().join("/");if(!t.has(c)&&(t.add(c),!j(r,o))){const l=r.slice(),h=o.slice();return e.edges.push({start:l,end:h,word:n}),!0}}const p=(e,n,r,o)=>{const{rules:t,words:s}=e,i=String.fromCharCode(97+r);if(n.slice(-1)===i)return;let c=n+i;if(c=y(t.rules,c),s.has(c)){const h=s.get(c);x(e,n,o,h);return}const l=F(e,c);return s.set(c,l),m(e,l,c),x(e,n,o,l),c},I=e=>{const{words:n,rootVertex:r,nextWords:o}=e;let t=[""],s;const i=1e3,c=r.length;m(e,r,"");let l=o;do{s=[];for(let h=0;h<l.length;h++){const w=l[h],O=n.get(w);for(let g=0;g<c-1;g++){const C=p(e,w,g,O);C&&s.push(C)}}t=t.concat(s),l=s}while(s.length&&t.length<=i);if(t.length>i)throw new Error("Could not tile fundamental chamber");return t},M=e=>{const{words:n,nextWords:r,currentOrder:o}=e;if(o===0)try{return I(e)}catch(s){console.warn(s)}let t;t=[];for(let s=0;s<r.length;s++){const i=r[s],c=n.get(i);for(let l=0;l<c.length;l++){const h=p(e,i,l,c);h&&t.push(h)}}return t};onmessage=({data:e})=>{try{const n=e.vertices.length,r=e.edges.length;e.nextWords=M(e),e.ranges[e.currentOrder]={vertices:[n,e.vertices.length],edges:[r,e.edges.length]},e.currentOrder++,postMessage(e)}catch(n){postMessage({error:n.message,uuid:e.uuid})}}})();
