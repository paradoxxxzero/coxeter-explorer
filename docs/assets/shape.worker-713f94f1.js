(function(){"use strict";const D=["vertex","edge","face","cell","4-face","5-face","6-face","7-face","8-face","9-face"],{abs:L,cos:ht,sin:pt,tan:vt,cosh:mt,sinh:yt,acos:wt,acosh:bt,atan:jt,atan2:kt,min:xt,max:Ct,round:ze,sqrt:ge,cbrt:Ot,sign:St,ceil:Vt,floor:Mt,log:Wt,exp:_t,hypot:At,pow:Ee,PI:zt}=Math,$e=(...e)=>e.reduce((t,n)=>t+n,0)/e.length,de=new ArrayBuffer(8),Ie=new Float64Array(de),he=new Int32Array(de);function Fe(e){return~~e===e?~~e:(Ie[0]=e,he[0]^he[1])}const pe=10**4,ve=e=>{let t="";for(let n=0;n<e.length;n++)t+=Fe(ze(e[n]*pe)/pe).toString(),n<e.length-1&&(t+="|");return t},Re=e=>e.sort((t,n)=>{for(let s=0;s<t.length;s++){if(t[s]<n[s])return-1;if(t[s]>n[s])return 1}return 0}),U=e=>Re(e).map(t=>ve(t)).join("-"),q=e=>String.fromCharCode(97+e),me=e=>e.charCodeAt(0)-97,I=e=>{const t=e.toUpperCase();return e===t?e.toLowerCase():t},ye=(e,t=null,n=1,s=!1)=>{if(t===null&&(t=e,e=0),n===0)throw new Error("Step cannot be zero.");if(t<e&&n>0||t>e&&n<0){if(s)return[];n=-n}return new Array(Math.ceil((t-e)/n)).fill().map((i,g)=>e+g*n)},Pe=e=>e==="m"||e==="b"||e==="c"||e==="d",Ge=e=>e==="c"||e==="d",F=e=>e==="s"||e==="b"||e==="d",P=(e,t)=>{let n=0;for(let s=0;s<e.length;s++)n+=e[s]*t[s];return n},Ne=(e,t)=>[e[1]*t[2]-e[2]*t[1],e[2]*t[0]-e[0]*t[2],e[0]*t[1]-e[1]*t[0]],Z=(e,t)=>{const n=[];for(let s=0;s<e.length;s++)n[s]=e[s]+t[s];return n},se=(e,t)=>{const n=[];for(let s=0;s<e.length;s++)n[s]=e[s]-t[s];return n},z=(e,t)=>{const n=[];for(let s=0;s<e.length;s++)n[s]=e[s]*t;return n},re=e=>{const t=[];for(let n=0;n<e[0].length;n++){t.push([]);for(let s=0;s<e.length;s++)t[n].push(e[s][n])}return t},K=(e,t)=>{const n=new Array(e.length);for(let s=0;s<e.length;s++){let i=0;for(let g=0;g<e[0].length;g++)i+=e[s][g]*t[g];n[s]=i}return n},Te=e=>{const t=new Array(e.length);for(let n=0;n<e.length;n++)t[n]=new Array(e.length).fill(0),t[n][n]=e[n];return t},G=e=>{const t=new Array(e).fill(1);return Te(t)},ie=(e,t)=>e.filter((n,s)=>!t.includes(s)),we=(e,t)=>ie(e,t).map(n=>ie(n,t)),N=(e,t,n)=>se(e,z(K(Be(n),t),2*P(K(He(n),e),t))),J=(e,t)=>{if(t.some((s,i)=>s.some((g,l)=>i===l&&g===0)))return e[e.length-1]===0&&(e[e.length-1]=1e-16),z(e,1/e[e.length-1]);let n=P(K(t,e),e);return n===0&&(n=1e-16),z(e,-1/ge(L(n)))},qe=1,He=e=>e.map((t,n)=>t.map((s,i)=>n===i&&s===0?qe:s)),Be=e=>e.map(t=>t.map(n=>L(n))),De=e=>{const t=[];for(let l=0;l<e.length;l++)for(let r=l+1;r<e.length;r++)e[l][r]!==2&&t.push([l,r]);if(t.length!==e.length-1)return;const n=new Array(e.length).fill(0);if(t.forEach(([l,r])=>{n[l]++,n[r]++}),n.some(l=>l>3)||n.filter(l=>l===1).length!==2)return;const i=[n.indexOf(1)],g=[];for(let l=0;l<e.length-1;l++){const r=i[i.length-1],o=t.findIndex(u=>u.includes(r));let f=t[o];t.splice(o,1),f[0]===r&&f.reverse(),i.push(f[0]),g.push(f.reverse())}return{group:i,pairs:g}},Le=e=>{const t=new Array(e.length).fill(0);for(let i=0;i<e.length;i++)for(let g=i+1;g<e.length;g++)e[i][g]!==2&&(t[i]++,t[g]++);if(t.filter(i=>i===3).length!==1||t.filter(i=>i===1).length!==e.length-1)return;const n=t.indexOf(3),s=t.map((i,g)=>[g,n]).filter(([i,g])=>i!==g);return{group:[n],pairs:s}},Ue=e=>{const t=De(e);if(t)return{type:"c",description:"C-Group",...t};const n=Le(e);return n?{type:"star",description:"Star Group",...n}:{type:"other",description:"Other Group"}},le=(e,t="",n=[])=>{const s=[];for(let i=0;i<e.length;i++){const[g,l]=e[i],r=e.filter((o,f)=>f!==i);if(n.length){const o=n[n.length-1];if(l.some(f=>f===o)){const f=l[1]===o,u=f?g.toUpperCase():g,c=f?[...l].reverse():l;if(c[1]===n[0])return[t+u];r.length&&s.push(...le(r,t+u,n.concat(c.slice(1))))}}else s.push(...le(r,g,l))}return s},Ze=(e,t)=>{var o,f;const n=[],s=Object.entries(e),i=s.filter(([u,c])=>c.length===1),g=s.filter(([u,c])=>c.length===2),l=s.filter(([u,c])=>c.length===3),r=Object.fromEntries(i.map(([u,c])=>[c[0],u]));for(let u=0;u<s.length;u++){const[c,p]=s[u];if([1,3].includes(p.length)&&n.push(c.repeat(2)),p.length===2){const h=t[p[0]][p[1]];h>1&&n.push(c.repeat(h))}if(p.length===1){const h=p[0];for(let d=0;d<i.length;d++){const[v,a]=i[d];if(a>h){const m=t[h][a];m>1&&n.push((c+v).repeat(m))}}}if(p.length===3){const h=t[p[0]][p[1]];if(h>1){const d=r[p[1]];d?n.push((c+d).repeat(h%2===0?h/2:h)):console.warn("No conjugate conjugate reflection",c,p)}for(let d=0;d<l.length;d++){const[v,a]=l[d];if(a[1]===p[1]&&a[0]>p[0]){let m=(o=g.find(([j,y])=>y[0]===p[0]&&y[1]===a[0]))==null?void 0:o[0];m||(m=I((f=g.find(([j,y])=>y[1]===p[0]&&y[0]===a[0]))==null?void 0:f[0])),m&&n.push(I(c)+I(m)+v+m)}if(a[0]===p[0]&&a[1]>p[1]){const m=t[p[1]][a[1]];m>1&&n.push((c+v).repeat(m))}}}}if(g.length>1){const u=le(g);n.push(...u.map(c=>c.split("").reverse().join("")))}return n},Ke=(e,t,n)=>{const s=[];if(t.length>2&&t.length<6&&n.some((r,o)=>r.some((f,u)=>f>1&&t[o][u]>1))){const r=Ue(t);r.type==="c"?s.push(...Je(t,n,r.group,r.pairs)):r.type==="star"&&s.push(...Qe(t,n,r.group,r.pairs))}t.length===3&&t[0][1]===5&&t[0][2]===3&&t[1][2]===5&&(n[0][1]===3&&n[0][2]===1&&n[1][2]===1||n[0][1]===1&&n[0][2]===1&&n[1][2]===3)&&s.push(T(2,[0,1,2,1]));const i=Object.fromEntries(Object.entries(e).filter(([r,o])=>o.length===1).map(([r,o])=>[o[0],r])),g=Object.entries(e).filter(([r,o])=>o.length===2).map(([r,o])=>[[o,r],[[...o].reverse(),I(r)]]).flat(),l=[];for(let r=0;r<s.length;r++){const o=s[r];let f="",u=!1;for(let c=0;c<o.length;c++){const p=o[c],h=i[p];if(h)f+=h;else{const d=g.find(([v,a])=>v[0]===p&&c<o.length-1&&v[1]===o[c+1]);if(d)f+=d[1],c++;else{u=!0;break}}}u||l.push(f)}return t.length===3&&e.a.length===2&&e.b.length===3&&e.c.length===3&&t[0][1]!==2&&t[1][2]===3&&l.push("abcb".repeat(2)),t.length===3&&e.a.length===1&&e.b.length===3&&e.c.length===3&&t[1][2]!==2&&t[0][1]===3&&l.push("dcbc".repeat(2)),l},T=(e,t)=>Array(e).fill(t).flat(),Je=(e,t,n,s)=>{const i=[];if(!s.filter(([h,d])=>t[h][d]>1).map(([h,d])=>e[h][d]===5))return i;const l=s.map(([h,d])=>e[h][d]);if(l.filter(h=>h!==3&&h!==5).length>(e.length===3?0:1))return i;if(l.filter(h=>h!==3&&h!==5).length===1){const h=l.findIndex(d=>d!==3&&d!==5);if(![0,l.length-1].includes(h))return i}const r=[l,[...l].reverse()],o=s.map(([h,d])=>t[h][d]),f=[o,[...o].reverse()],u=({m:h,s:d})=>{if(h.length!==e.length-1)return!1;for(let v=0;v<r.length;v++){const a=r[v],m=f[v];if(a.every((j,y)=>j===h[y]||h[y]===null)&&m.every((j,y)=>j===d[y]||d[y]===null))return!0}};if(u({m:[null,5,5],s:[null,1,2]})&&(l[o[0]===2?l.length-1:0]=0),[{m:[null,3,5,5],s:[null,1,1,2]},{m:[null,5,5,5],s:[null,1,2,1]},{m:[null,5,3,5],s:[null,1,1,2]}].some(u)||(u({m:[5,5,5,3],s:[1,1,2,1]})&&(l[o[1]===2?l.length-1:0]=0),l.filter(h=>h===3).length>e.length-3))return i;const c=[];let p=[];for(let h=0;h<l.length;h++)l[h]===5&&(p.length?(p.push(h),c.push(p),p=[h]):p.push(h));for(let h=0;h<c.length;h++){const[d,v]=c[h],a=[];for(let m=d;m<v+2;m++)a.push(n[m]);a.push(...a.slice(1,a.length-1).reverse()),i.push(T(3,a))}return i},Qe=(e,t,n,s)=>{const i=[];if(e.length!==4||!s.filter(([f,u])=>t[f][u]>1).map(([f,u])=>e[f][u]===5))return i;const l=s.map(([f,u])=>e[f][u]);if(l.find(f=>f!==3&&f!==5)||l.filter(f=>f===3).length!==1)return i;const r=s[l.findIndex(f=>f===3)],o=s.filter(([f,u])=>e[f][u]===5);return i.push(T(3,[...o[0],...o[1]])),i.push(T(2,[...T(3,[o[1][0],...r].reverse()),...T(2,[...o[0]].reverse())])),i},Xe=e=>{for(e=e.replace(/\s/g,""),e=e.replace(/(\w)(\^-?\d+)/g,"($1)$2");;){let t=e.replace(/\((\w+)\)\^(-?\d+)/g,(n,s,i)=>(i=parseInt(i),i<0&&(s=s.split("").reverse().map(g=>I(g)).join(""),i=-i),s.repeat(i)));if(t===e)break;e=t}return e},be=e=>{for(e=e.replace(/\s/g,"");;){let t=e.replace(/(\w+)(\1)+/g,(n,s)=>{const i=n.length/s.length;return`(${s})^${i}`});if(t=t.replace(/\(\((\w+)\)\^(\d+)\)\^(\d+)/g,(n,s,i,g)=>`(${s})^${parseInt(i)*parseInt(g)}`),t=t.replace(/\((\w+)\)\^(\d+)(\1)/g,(n,s,i)=>`(${s})^${parseInt(i)+1}`),t=t.replace(/(\w+)\(\1\)\^(\d+)/g,(n,s,i)=>`(${s})^${parseInt(i)+1}`),t===e)break;e=t}return e=e.replace(/\(([A-Z]+)\)\^(\d+)/g,(t,n,s)=>(n=n.split("").reverse().map(i=>I(i)).join(""),`(${n})^-${s}`)),e=e.replace(/([A-Z]+)/g,(t,n)=>(n=n.split("").reverse().map(s=>I(s)).join(""),`(${n})^-1`)),e=e.replace(/\((\w)\)(\^-?\d+)/g,"$1$2"),e};typeof window<"u"&&(window.factor=be);const A=(e,t)=>{let n=t,s=0;for(;e.quotientMap[n];)s++,n=e.quotientMap[n];return s>1&&(e.quotientMap[t]=n),n},je=(e,t,n)=>{const s=t,i=[[t,n]];for(;i.length>0;)if([t,n]=i.pop(),t>n&&([t,n]=[n,t]),t=A(e,t),n=A(e,n),t!==n){e.quotientMap[n]=t,e.seen.has(n)&&!e.seen.has(t)&&e.seen.add(t);const g=e.cosets.get(t),l=e.cosets.get(n);e.cosets.delete(n);for(const[r,o]of l)g.has(r)?i.push([g.get(r),o]):g.set(r,o)}return A(e,s)},ke=(e,t,n,s)=>{t=A(e,t);const i=e.cosets.get(t);i.has(n)?je(e,i.get(n),s):i.set(n,s)},Q=(e,t,n,s)=>{t=A(e,t);let i;const g=e.cosets.get(t);return g.has(n)?(i=A(e,g.get(n)),s!==void 0&&i!==s&&je(e,s,i)):(s?i=s:(i=e.nextVertex++,e.cosets.set(i,new Map),e.unvisited.push(i)),ke(e,t,n,i),ke(e,i,I(n),t)),i},xe=function(e,t,n){let s=n;for(let i=t.length-1;i>0;i--)s=Q(e,s,t[i]);Q(e,s,t[0],n)},Ye=function(e){var n,s;if(!e.words){const i=A(e,1);e.words=new Map,e.words.set(i,""),(e.compound||!e.dual)&&(e.currentWords=new Map,e.currentWords.set(i,"")),(e.compound||e.dual)&&(e.dualCurrentWords=new Map,e.dualCurrentWords.set(i,"")),e.lastCoset=i,e.remaining=[i],e.rootVertex&&e.rootNormals&&e.metric&&(e.vertices=new Map,e.vertices.set(i,e.rootVertex))}const t=new Set;for(;e.remaining.length>0;){const i=e.remaining[0],g=A(e,i),l=e.cosets.get(g),r=e.words.get(g);if(r===void 0){if(t.has(i)){console.warn("Failed to find word for coset",i);return}e.remaining.push(e.remaining.shift()),t.add(i);continue}if(l.size<e.gens.length*2)return;const o=[];for(let f=0;f<e.gens.length;f++){const u=e.gens[f],c=A(e,l.get(u));if(!e.words.has(c)){if(e.cosets.get(c).size<e.gens.length*2)return;o.push([u,c])}}e.remaining.shift();for(let f=0;f<o.length;f++){const[u,c]=o[f],p=u+r;if(e.words.set(c,p),(n=e.currentWords)==null||n.set(c,p),(s=e.dualCurrentWords)==null||s.set(c,p),e.lastCoset=c,e.remaining.push(c),e.vertices){let h=e.vertices.get(g);for(let d=0;d<e.transforms[u].length;d++){const v=e.transforms[u][d];h=N(h,e.rootNormals[v],e.metric)}e.vertices.set(c,h)}}}},$=(e,t)=>{let n=A(e,1);for(let s=t.length-1;s>=0;s--){const i=e.cosets.get(n);if(i.size<e.gens.length*2||(n=A(e,i.get(t[s])),e.cosets.get(n).size<e.gens.length*2))return}return n},Ce=e=>{if(e.cosets)e.unvisited.splice(0,e.pointer),e.pointer=0;else{e.unvisited=[1],e.pointer=0,e.cosets=new Map([[1,new Map]]),e.nextVertex=2,e.seen=new Set,e.quotientMap={};for(let t=0;t<e.subgens.length;t++)xe(e,e.subgens[t],1)}e.limit=e.limit||1e3,e.done=!1;for(let t=0;t<e.limit;t++){let n=null;for(;e.unvisited.length-e.pointer>0;){const s=e.unvisited[e.pointer++],i=A(e,s);if(!e.seen.has(i)){e.seen.add(i),n=i;break}}if(n===null){e.done=!0;break}for(let s=0;s<e.gens.length;s++)Q(e,n,e.gens[s].toUpperCase()),Q(e,n,e.gens[s]);for(let s=0;s<e.rels.length;s++)xe(e,e.rels[s],n)}},et=e=>(Ce(e),e.cosets.size),Oe=e=>(Ce(e),Ye(e),e),Se=(e,t,n)=>{if(n){t%2&&t--;const s=e>0?1-e%2:0;return e>=t/2+s?2*(t-e)-1+s:2*e-s}return e>=t/2?2*(t-e)-1:2*e},tt=(e,t,n)=>{if(t===0)return!0;if(e.length<=t)return!1;const s=new Set;for(let i=0;i<e.length;i++){const g=e[i];if(g)for(let l=0;l<g.length;l++){const r=g[l];for(let o=0;o<n[r].length;o++){const f=q(n[r][o]);s.has(f)||s.add(f)}if(s.size>=t)return!0}}return!1},oe=(e,t,n,s,i,g,l=null,r=null)=>{if(!l){s.every(d=>!d)&&(s=s.map(()=>1));let f="",u=0;const c={};for(let d=0;d<e;d++){if(!F(s[d])){const v=q(u++);f+=v,c[v]=[d]}for(let v=d+1;v<e;v++)if(F(s[d])&&F(s[v])){const a=q(u++);f+=a,c[a]=[d,v]}else if(F(s[d])&&!F(s[v])){const a=q(u++);f+=a,c[a]=[d,v,d]}else if(!F(s[d])&&F(s[v])){const a=q(u++);f+=a,c[a]=[v,d,v]}}const p=Object.entries(c).filter(([d,v])=>v.every(a=>!s[a])).map(([d])=>d).join(""),h=Ze(c,t);if(g){const d=g.split(",");for(let v=0;v<d.length;v++){let a=d[v];a=a.replace(/\s/g,""),a&&(a=Xe(a),a.split("").every(m=>f.includes(m.toLowerCase()))&&h.push(a))}}else{const d=Ke(c,t,n);h.push(...d),g=d.map(v=>be(v)).join(", ")}if(l={new:!0,key:"",dimensions:e,coxeter:t,stellation:n,mirrors:s,gens:f,subgens:p,transforms:c,rels:h,extrarels:g,facet:[""],removed:[],children:[]},r=l,r.solved=new Map,s.length>1&&s.filter(d=>d).length===1){const d=s.findIndex(v=>v);if(t[d].every((v,a)=>d===a||v===2)){const v=d===e-1?e-2:d+1,[a]=Object.entries(l.transforms).find(([m,j])=>j.includes(v));r.hosotope={gen:a,index:v}}}}const o=[];for(let f=0;f<e;f++){if(l.removed.includes(f))continue;let u=l.gens.split("").filter(a=>!l.transforms[a].includes(f)).join("");const c=[...l.removed,f],p=c.sort().join("-");let h=!1;if(!r.solved.has(p)){h=!0;const a={dimensions:l.dimensions-1,coxeter:we(r.coxeter,c),stellation:we(r.stellation,c),mirrors:ie(r.mirrors,c),gens:u,subgens:r.subgens.split("").filter(m=>u.includes(m)).join(""),rels:r.rels.filter(m=>m.toLowerCase().split("").every(j=>u.includes(j))),transforms:Object.fromEntries(Object.entries(l.transforms).filter(([m])=>u.includes(m))),removed:c,key:p,limit:i.curvature>0?2500:1e3};Oe(a),a.facet=Array.from(a.words.values()),r.solved.set(p,a),a.dimensions===0&&(r.root=a)}const d=r.solved.get(p),v=r.hosotope&&d.removed.length&&d.removed[0]===r.hosotope.index&&d.removed.every((a,m)=>m===0||a===(d.removed[m-1]+1)%e);if(tt(d.facet,d.dimensions,r.transforms)||v){if(h&&d.dimensions===2){const m=[...d.facet],j=d.gens.split("").every(b=>r.mirrors[r.transforms[b][0]]),y=d.gens.split("").every(b=>r.transforms[b].length===2);for(let b=0;b<m.length;b++)d.facet[b]=m[y?b:Se(b,d.facet.length,j)]}const a={new:h,children:[],...d};a.removed.length<e?l.children.push(oe(e,t,n,s,i,g,a,r)):l.children.push(a)}else o.push(d)}if(l.children.length===0&&l.dimensions>0){console.debug("No leaf found, digging deeper",l.gens);for(let f=0;f<o.length;f++){const u=o[f],c={new:!1,children:[],...u};c.removed.length<e?l.children.push(oe(e,t,n,s,i,g,c,r)):l.children.push(c)}}if(l===r&&s.some(f=>F(f))){let f="",u=[];for(let c=1;c<e;c++)if(c===1){const p=[],h=y=>{y.dimensions===1?y.new&&p.push(y):y.children.forEach(h)};h(l);const d=Object.entries(r.transforms).filter(([y,b])=>b.length!==1||s[b[0]]).filter(([y,b])=>b.length!==3||t[b[0]][b[1]]!==2).map(([y])=>y);for(let y=0;y<p.length;y++){const b=p[y];d.includes(b.gens)&&d.splice(d.indexOf(b.gens),1)}const v=u;u=[];const a=G(1).map((y,b)=>y.map((k,w)=>b===w?1:b===w+1||b===w-1?4:2)),m=G(1).map(y=>y.map(()=>1)),j=ye(1).map(()=>"s");for(let y=0;y<d.length;y++){const b=d[y],k={dimensions:1,coxeter:a,stellation:m,mirrors:j};k.gens=b;const w={new:!0,done:!0,key:`se-${b}`,...k,facet:["",b],children:y===0?v:[]};u.push(w)}}else if(c===2){const p=k=>G(2).map((w,x)=>w.map((W,O)=>x===O?1:x===O+1||x===O-1?k:2)),h=k=>G(2).map(w=>w.map(()=>k)),d={},v=Object.entries(r.transforms).filter(([k,w])=>w.length===2),a=Object.entries(r.transforms).filter(([k,w])=>w.length===3);let m="";const j=k=>{k.dimensions===2?k.new&&k.gens.length===1&&(m+=k.gens):k.children.forEach(j)};j(l),f+=m;for(let k=0;k<v.length;k++){const[w,x]=v[k];for(let W=k+1;W<v.length;W++){const[O,V]=v[W];x[x.length-1]===V[V.length-1]&&(d[w+O]={facet:["",w,O]},f+=w+O)}}for(let k=0;k<a.length;k++){const[w,x]=a[k];for(let W=k+1;W<a.length;W++){const[O,V]=a[W];if(x[0]===V[0]&&t[x[1]][V[1]]!==2&&(t[x[1]][x[0]]!==2||t[x[0]][V[1]]!==2)){const B=t[x[1]][V[1]],ee=s[V[1]]||t[x[0]][V[1]]!==2,te=[];for(let ne=0;ne<B;ne++)ee&&te.push(w+(O+w).repeat(B-ne)),te.push((O+w).repeat(ne));d[w+O]={facet:te,snubCoxeter:p(te.length),snubMirrors:["s",ee?1:0]},f+=w+O}}for(let W=0;W<v.length;W++){const[O,V]=v[W];x[0]===V[1]&&(t[x[1]][V[0]]!==2||t[x[1]][V[1]]!==2||s[x[1]])&&(s[x[1]]||t[x[1]][V[0]]!==2&&t[x[1]][V[1]]!==2?d[w+O]={facet:["",w,w+O,O],snubCoxeter:p(4)}:t[x[1]][V[0]]!==2?d[w+O]={facet:["",O,w+O]}:d[w+O]={facet:["",w,O]},f+=w+O)}}const y=u;u=[],Object.keys(d).length||(d[""]={facet:[""]});const b=Object.entries(d);for(let k=0;k<b.length;k++){const[w,{facet:x,snubCoxeter:W,snubStellation:O,snubMirrors:V}]=b[k],B={dimensions:2,coxeter:W||p(3),stellation:O||h(1),mirrors:V||["s","s"]};B.gens=w;const ee={new:x.length!==1,done:!0,key:`sf-${w}`,...B,facet:x,children:k===0?y:[]};u.push(ee)}}else{const p=G(c).map((j,y)=>j.map((b,k)=>y===k?1:2)),h=G(c).map(j=>j.map(()=>1)),d=ye(c).map(()=>"s"),v=u;u=[];let a=f;const m={new:!0,done:!0,key:`s${c}`,gens:l.gens.split("").filter(j=>!a.includes(j)).join(""),dimensions:c,coxeter:p,stellation:h,mirrors:d,facet:[],children:v};u.push(m)}l.children.push(...u)}return l===r&&!l.root&&(l.root=l),l},ce=(e,t,{p:n,normal:s})=>{const i=P(se(n,e),s)/P(se(t,e),s);if(i<0||i>1)return;const g=[];for(let l=0;l<e.length;l++)g.push(e[l]+i*(t[l]-e[l]));return g},nt=(e,t,n,s)=>{const i=[],g=[];if(e===0)for(let l=0;l<n.length;l++){const r=n[l],{vertices:o,partial:f}=r,u=ce(o[0],o[1],t);if(!u)continue;const c={...r,vertices:[u]};f?g.push(c):i.push(c)}else if(e===1){s.crossEdges||(s.crossEdges=new Map);for(let l=0;l<n.length;l++){const r=n[l],o=[],f=[];for(let c=0;c<r.vertices.length;c++){const p=r.vertices[c],h=r.vertices[(c+1)%r.vertices.length],d=ce(p,h,t);d&&(f.push(U([p,h])),o.push(d))}if(o.length<2)continue;if(!r.partial)for(let c=0;c<2;c++)s.crossEdges.has(f[c])?s.crossEdges.get(f[c]).add(f[(c+1)%2]):s.crossEdges.set(f[c],new Set([f[(c+1)%2]]));const u={...r,vertices:o};r.partial?g.push(u):i.push(u)}}else if(e===2){s.unfinishedCells||(s.unfinishedCells=new Map);const l=[...n,...Array.from(s.unfinishedCells.values())];for(let r=0;r<l.length;r++){const o=l[r],f=[],u=[];for(let a=0;a<o.vertices.length;a++)for(let m=a+1;m<o.vertices.length;m++){const j=U([o.vertices[a],o.vertices[m]]);if(s.crossEdges.has(j)){const y=ce(o.vertices[a],o.vertices[m],t);if(!y)continue;u.push([j,s.crossEdges.get(j)]),f.push(y)}}if(f.length<3){!s.unfinishedCells.has(o.word)&&!o.partial&&s.unfinishedCells.set(o.word,o);continue}const c=[0];let p=u[0][1];for(let a=0;a<u.length;a++)for(let m=0;m<u.length;m++)if(!c.includes(m)&&p.has(u[m][0])){c.push(m),p=u[m][1];break}let h=o.partial;c.length<f.length?(h=!0,!s.unfinishedCells.has(o.word)&&!o.partial&&s.unfinishedCells.set(o.word,o)):s.unfinishedCells.delete(o.word);const d=[];for(let a=0;a<c.length;a++)d.push(f[c[a]]);const v={...o,vertices:d,partial:h};h?g.push(v):i.push(v)}}return{sections:i,sectionPartials:g}},Ve=(e,t,n)=>{const s=t.slice(0,-1),i=t[t.length-1],g=z(s,1/ge(P(s,s))),r={p:z(g,i),normal:g},o=[];for(let f=0;f<3;f++){const u=e[f+1],c={objects:[],partials:[]};if(u){const p=u.objects.concat(u.partials);for(let h=0;h<p.length;h++){const d=p[h]||[],{sections:v,sectionPartials:a}=nt(f,r,d,n);c.objects.push(v),c.partials.push(a)}}o.push(c)}return o},fe=(e,t,n)=>(n<0&&(n+=1),n>1&&(n-=1),n<1/6?e+(t-e)*6*n:n<1/2?t:n<2/3?e+(t-e)*(2/3-n)*6:e),M=(e,t,n)=>{let s,i,g;if(t===0)s=i=g=n;else{const l=n<.5?n*(1+t):n+t-n*t,r=2*n-l;s=fe(r,l,e+1/3),i=fe(r,l,e),g=fe(r,l,e-1/3)}return[s,i,g]},X=[[10/360,.56,.91],[0/360,.59,.88],[316/360,.72,.86],[267/360,.84,.81],[343/360,.81,.75],[350/360,.65,.77],[23/360,.92,.75],[41/360,.86,.83],[115/360,.54,.76],[170/360,.57,.73],[189/360,.71,.73],[199/360,.76,.69],[217/360,.92,.76],[232/360,.97,.85]],st={background:[0,0,0,1],glow:!1,shading:"ads",diffuse:"lambert",specular:!1,shininess:32,opacity:1,ambient:.2,roughness:.85,gouraud:!1,transparency:"oit",color:({word:e})=>M(e.length*.03%1,.75,.7)},rt=Object.fromEntries(Object.entries({neon:{background:[0,0,0,1],glow:{exposure:1.75,strength:2,offset:{up:2,down:2},steps:3,pow:2},shading:!1,face:{opacity:.025},transparency:"blend",color:({word:e,dual:t})=>M((e.length*.17-(t?.43:0))%1,.5,.6)},disco:{background:[0,0,0,1],glow:{exposure:1.5,strength:2,offset:{up:2,down:2},steps:4,pow:2},face:{gouraud:!0,diffuse:"fresnel",opacity:.025},transparency:"blend",color:({word:e})=>M(...X[e.length%X.length])},cathedral:{background:[.6,.6,.6,1],glow:{exposure:1.5,strength:2,offset:{up:2,down:2},steps:4,pow:2},shading:!1,face:{opacity:.9},transparency:"oit",color:({word:e,subShape:t,type:n})=>n==="face"?M((t*.23+e.length*.07)%1,1,.58):[0,0,0]},synthwave:{background:[...M(.77,.6,.04),1],glow:{exposure:1.5,strength:3,offset:{up:3,down:3},steps:3,pow:2},shading:!1,face:{opacity:.015},afterImage:.7,transparency:"blend",color:({word:e})=>M((.5-e.length*.05%.5+.65)%1,.4,.6)},colorful:{background:[1,1,1,1],diffuse:"oren-nayar",specular:"cook-torrance",shininess:32,opacity:1,ambient:.2,gouraud:!1,face:{gouraud:!0,opacity:.1,diffuse:"fresnel",specular:!1},transparency:"oit",color:({word:e,dual:t})=>M(e.length*.03%1-(t?.25:0),1,.8)},shiny:{background:[0,0,0,1],diffuse:"lambert",specular:"blinn-phong",shininess:32,opacity:1,ambient:.2,gouraud:!1,face:{gouraud:!0,opacity:.1,diffuse:"fresnel",specular:!1},transparency:"oit",color:({word:e})=>M(-(e.length*.07)%1,1,.8)},flare:{background:[1,1,1,1],transparency:"blend",diffuse:"cel",face:{opacity:.6,gouraud:!1},color:({word:e})=>M(e.length*.09%1,1,.8)},shape:{background:[1,1,1,1],transparency:"oit",face:{gouraud:!0,opacity:.2,diffuse:"fresnel"},color:({subShape:e,type:t})=>t!=="vertex"?M(e*.21%1,1,.8):[1,1,1]},reflection:{background:[1,1,1,1],transparency:"blend",diffuse:"cel",face:{opacity:.6,gouraud:!1},color:({word:e,type:t,dimensions:n,hidden:s})=>{const i=e.length?me(e[e.length-1])/n:0;return M(i%1,1,t==="face"?.6:s.includes("face")?.8:0)}},harlequin:{background:[...M(240/360,.23,.09),1],face:{opacity:.6},transparency:"oit",color:({word:e,idx:t,type:n})=>{const s=e.split("").map(g=>me(g)).reduce((g,l)=>g+l,0),i=[...X[s%X.length]];return t%2&&(i[2]*=.5),M(...i)}},pure:{background:[0,0,0,1],color:({word:e})=>M(e.length*.03%1,.75,.7)},facets:{background:[0,0,0,1],color:({faceIndex:e,faceSize:t})=>M((e||0)/(t||1),.75,.7)},monochrome:{background:[.12,.12,.12,1],diffuse:"reverse",ambient:0,face:{opacity:.1},transparency:"oit",color:()=>[1,1,1]},glass:{background:[0,0,0,1],transparency:"blend",opacity:.2,ambient:0,diffuse:"fresnel",specular:"blinn-phong",face:{shininess:16,diffuse:!1},color:({subShape:e,word:t,type:n})=>n!=="vertex"?M((e*.21+t.length*.03)%1,1,.8):[1,1,1]},plain:{extended:!0,background:[1,1,1,1],glow:!1,shading:!1,color:({word:e,type:t,hidden:n})=>M(e.length*.06%1,1,t==="face"?.6:n.includes("face")?.5:.05)},plainblack:{extended:!0,background:[1,1,1,1],shading:!1,color:({word:e,type:t})=>t==="face"?new Array(3).fill(1-Ee(.9,e.length+1)):[0,0,0]},normals:{extended:!0,background:[1,1,1,1],shading:"normal",color:()=>[0,0,0]},uvs:{extended:!0,background:[1,1,1,1],shading:"uv",color:()=>[0,0,0]}}).map(([e,t])=>[e,{...st,...t,transparent:{}}])),Me=e=>e>4?9:e<1?1:e,We=(e,t)=>{const n=[];let s=0;for(let i=0;i<2;i++){const g=i===1?e.partials:e.objects;for(let l=0;l<g.length;l++){const r=g[l];for(let o=0;o<r.length;o++){const f=r[o];t.includes(f.key)||t.includes(f.key.split("_")[0])||(i===0&&s++,n.push(f))}}}return{allObjects:n,nonpartial:s}},ue=(e,t,n,s)=>{const i=[],g=[],l=Me(e);for(let r=0;r<t.length;r++){const o=t[r],{allObjects:f,nonpartial:u}=We(o,n),c=[];for(let p=0;p<r+1;p++)c.push(new Float32Array(f.length*l));for(let p=0;p<f.length;p++){const h=f[p];for(let d=0;d<h.vertices.length;d++){const v=h.vertices[d];for(let a=0;a<v.length;a++)c[d][p*l+a]=v[a]}}i.push(c),g.push({start:s?s[r]:0,size:f.length,nonpartial:u,arity:l})}return{infos:g,data:i}},Y=(e,t,n,s,i)=>{const g=[],l=[],r=Me(e);for(let o=0;o<t.length;o++){const f=t[o],{allObjects:u}=We(f,s),c=new Float32Array(u.length*3);for(let p=0;p<u.length;p++){const h=u[p],d=rt[n].color({word:h.word,key:h.key,subShape:p%f.objects.length,faceIndex:h.faceIndex,faceSize:h.faceSize,dimensions:e,hidden:s,idx:p,size:u.length,type:D[o],dual:!!h.dual});c[p*3+0]=d[0],c[p*3+1]=d[1],c[p*3+2]=d[2]}g.push(c),l.push({start:i?i[o]:0,size:u.length,arity:r})}return{infos:l,data:g}},it=(e,t,n)=>{const s=[],i=[];if(e===0)for(const[g,l]of t.currentWords)s.push({key:t.key,word:l,vertices:[t.vertices.get(g)]}),t.currentWords.delete(g);else if(e===1)for(const[g,l]of t.currentWords){const r={key:t.key,word:l,vertices:[]};for(let o=0;o<t.facet.length;o++){const f=$(n,l+t.facet[o]);f&&n.vertices.has(f)&&r.vertices.push(n.vertices.get(f))}if(n.hosotope&&n.vertices.size===1&&r.vertices.push(N(r.vertices[0],n.rootNormals[n.hosotope.index-1],n.metric)),!(r.vertices.length<e+1)){if(n.hosotope){let o;if(n.hosotopeVertex?o=l.split("").reverse().reduce((f,u)=>N(f,n.rootNormals[n.gens.indexOf(u)],n.metric),n.hosotopeVertex):(n.hosotopeVertex=J(re(n.rootVertices)[n.hosotope.index],n.metric),o=n.hosotopeVertex),s.push({...r,vertices:[r.vertices[0],o]}),s.push({...r,vertices:[o,r.vertices[1]]}),n.vertices.size===1){const f=o.map(u=>-u);s.push({...r,vertices:[r.vertices[0],f]}),s.push({...r,vertices:[f,r.vertices[1]]})}}else s.push(r);t.currentWords.delete(g)}}else if(e===2){n.hosotopePair=null;for(const[g,l]of t.currentWords){const r=[];for(let u=0;u<t.facet.length;u++){const c=$(n,l+t.facet[u]);c&&n.vertices.has(c)&&r.push(n.vertices.get(c))}if(n.hosotope){n.vertices.size===1&&r.push(r[0].map(c=>-c));let u;if(n.hosotopePair)u=n.hosotopePair.map(c=>l.split("").reverse().reduce((p,h)=>N(p,n.rootNormals[n.gens.indexOf(h)],n.metric),c));else{const c=J(re(n.rootVertices)[n.hosotope.index],n.metric);n.hosotopePair=[c,N(c,n.rootNormals[n.hosotope.index],n.metric)],u=n.hosotopePair}r.splice(1,0,u[0]),r.push(u[1]),n.vertices.size===1&&(r[3]=r[1].map(c=>-c))}if(r.length<e+1)continue;const o=r.length<t.facet.length||t.partial;o||t.currentWords.delete(g);const f={key:t.key,word:l,vertices:r,faceIndex:0,faceSize:r.length,partial:o};o?i.push(f):s.push(f)}}else if(e===3)for(const[g,l]of t.currentWords){const r=[];for(let u=0;u<t.facet.length;u++){const c=$(n,l+t.facet[u]);c&&n.vertices.has(c)&&r.push(n.vertices.get(c))}if(r.length<e+1)continue;const o=r.length<t.facet.length||t.partial;o||t.currentWords.delete(g);const f={key:t.key,word:l,vertices:r,faceIndex:0,faceSize:r.length,partial:o};o?i.push(f):s.push(f)}return{objects:s,partials:i}},ae=(e,t=null)=>{if(!e.length)return t||[];if(!t)return t=e[0],ae(e.slice(1),t);const n=t[t.length-1],s=e.find(g=>g[0]===n||g[1]===n);if(!s)return t;const i=e.indexOf(s);return e.splice(i,1),s[0]===n?t.push(s[1]):t.push(s[0]),ae(e,t)},lt=(e,t,n,s)=>{const i=[],g=t.children.find(o=>o.key===n.split("_").slice(-1)[0]),l=[],r=o=>{o.dimensions===e&&l.push(o.facet),o.children.forEach(r)};r(g),t.children.filter(o=>o.key.includes("s")).forEach(r);for(let o=0;o<l.length;o++){const f=l[o];if(f.length<2)continue;const u=[];for(let p=0;p<f.length;p++){const h=$(s,f[p]);h&&s.vertices.has(h)&&u.push(s.vertices.get(h))}let c=new Array(u[0].length).fill(0);for(let p=0;p<u.length;p++){const h=u[p];c=Z(c,h)}c=z(c,1/u.length),i.push(P(c,c))}return $e(...i)},ot=(e,t,n,s,i,g)=>{var f,u,c;const{space:l}=g,r=[],o=[];if(e===0){g.dualVertices=g.dualVertices||new Map;for(const[p,h]of t.dualCurrentWords){const d=[];for(let y=0;y<t.facet.length;y++){const b=$(g,h+t.facet[y]);b&&g.vertices.has(b)&&d.push(b)}if(d.length<2)continue;const v=d.length<t.facet.length;let a=new Array(n.dimensions).fill(0);for(let y=0;y<d.length;y++){const b=g.vertices.get(d[y]);a=Z(a,b)}if(a=J(a,l.metric),l.curvature){let y=0;if(s>=0){let b=1;s>0&&s<n.dimensions-1&&(t.midradius||(t.midradius=lt(s,n,i,g)),b=t.midradius);const k=K(l.metric,a);for(let w=0;w<d.length;w++){const x=g.vertices.get(d[w]);y+=P(k,x)}y/=b*d.length,s===n.dimensions-1&&(y=1/y)}else y=1;a=z(a,l.curvature/y)}const m={key:t.compound?t.key.replace(/_/,"dual_"):t.key,word:h,vertices:[a],dual:!0,partial:v},j=`${i}#${h}`;g.dualVertices.set(j,{vertex:a,facet:d,partial:v}),v?o.push(m):(r.push(m),t.dualCurrentWords.delete(p))}}else if(e===1){if(!((f=g.dualVertices)!=null&&f.size))return{objects:r,partials:o};g.dualEdges=g.dualEdges||new Map;for(const[p,h]of t.dualCurrentWords){const d=[];for(let y=0;y<t.facet.length;y++){const b=$(g,h+t.facet[y]);b&&g.vertices.has(b)&&d.push(b)}if(!d.length)continue;let v=d.length<t.facet.length;const a=[],m=[];for(const[y,{vertex:b,facet:k,partial:w}]of g.dualVertices.entries())if(d.every(x=>k.includes(x))&&(a.push(b),m.push(y)),v=v||w,a.length===2)break;if(a.length!==2)continue;const j={key:t.compound?t.key.replace(/_/,"dual_"):t.key,word:h,vertices:a,dual:!0,partial:v};g.dualEdges.set(`${i}#${h}`,{edge:m,partial:v}),v?o.push(j):(r.push(j),t.dualCurrentWords.delete(p))}}else if(e===2){if(!((u=g.dualVertices)!=null&&u.size)||!((c=g.dualEdges)!=null&&c.size))return{objects:r,partials:o};for(const[p,h]of t.dualCurrentWords){const d=[];for(let w=0;w<t.facet.length;w++){const x=$(g,h+t.facet[w]);x&&g.vertices.has(x)&&d.push(x)}if(d.length<t.facet.length)continue;let v=!1;const a={},m=[];for(const[w,{vertex:x,facet:W,partial:O}]of g.dualVertices.entries())(d.every(V=>W.includes(V))||n.dimensions===2)&&(a[w]=x,m.push(w),v=v||O);if(m.length<3)continue;const j=[];for(const{edge:w,partial:x}of g.dualEdges.values())m.includes(w[0])&&m.includes(w[1])&&(v=v||x,j.push([...w]));if(j.length<3)continue;const y=[],b=ae(j);if(b.length<4)continue;b[0]===b[b.length-1]&&b.pop();for(let w=0;w<b.length;w++){const x=b[w];y.push(a[x])}const k={key:t.compound?t.key.replace(/_/,"dual_"):t.key,word:h,vertices:y,dual:!0,faceSize:y.length,partial:v};v?o.push(k):(r.push(k),t.dualCurrentWords.delete(p))}}return{objects:r,partials:o}},ct=(e,t)=>{const n=[],s=[],i=[];for(const[g,l]of t.currentWords){let r;if(l===""){const o=re(t.space.rootVertices);t.fundamentalVertices=new Map,r=o.map(f=>J(f,t.space.metric)),t.hashes={vertex:new Set,edge:new Set,face:new Set},t.fundamentalVertices.set("",r)}else{r=[...t.fundamentalVertices.get(l.slice(1))];const o=t.gens.indexOf(l[0]);for(let f=0;f<r.length;f++)r[f]=N(r[f],t.space.rootNormals[o],t.space.metric)}for(let o=0;o<r.length;o++){if(e.dimensions<3){const u=new Array(e.dimensions).fill(0);if(n.push({key:"vertex",word:l,vertices:u}),e.dimensions===2){for(let c=0;c<r.length;c++)s.push({key:"edge",word:l,vertices:[u,z(r[c],1e3)]});i.push({key:"face",word:l,vertices:[u,z(r[o],1e3),z(r[(o+1)%r.length],1e3)]})}}else{const f=ve(r[o]);t.hashes.vertex.has(f)||(n.push({key:"vertex",word:l,vertices:[r[o]]}),t.hashes.vertex.add(f));for(let u=o+1;u<r.length;u++){const c=U([r[o],r[u]]);t.hashes.edge.has(c)||(s.push({key:"edge",word:l,vertices:[r[o],r[u]]}),t.hashes.edge.add(c));for(let p=u+1;p<r.length;p++){const h=U([r[o],r[u],r[p]]);t.hashes.face.has(h)||(i.push({key:"face",word:l,faceSize:3,vertices:[r[o],r[u],r[p]]}),t.hashes.face.add(h))}}}t.fundamentalVertices.set(l,r)}t.currentWords.delete(g)}return[n,s,i]},_e=(e,t)=>{const n={objects:[],partials:[]};for(let s=0;s<2;s++){const i=s===1,g=i?e.partials:e.objects;for(let l=0;l<g.length;l++){const r=g[l],o=[];for(let f=0;f<r.length;f++){const u=r[f],c=u.vertices[0].length,p=u.word.length%2?0:1;if(u.vertices.length===3&&!u.vertices.reduce((v,a)=>Z(v,a),new Array(c).fill(0)).every(v=>L(v)<1e-12)){o.push(u);continue}let h=new Array(c).fill(0);for(let v=0;v<u.vertices.length;v++){const a=u.vertices[v];h=Z(h,a)}h=z(h,1/u.vertices.length);const d=[];if(t.hosotope&&h.every(v=>L(v)<1e-12)){const v=Ne(u.vertices[0],u.vertices[1]),a=new Array(c).fill(0);v.map((m,j)=>a[j]=m),d.push(a),d.push(a.map(m=>-m));for(let m=3;m<c;m++){const j=[...a];j[2]=0,j[m]=a[2],d.push(j),d.push(j.map(y=>-y))}}else d.push(h);for(let v=0;v<u.vertices.length;v++)for(let a=0;a<d.length;a++){const m={...u,vertices:[u.vertices[(v+p)%u.vertices.length],u.vertices[(v+(1-p))%u.vertices.length],d[a]],faceIndex:v};o.push(m)}}i?n.partials.push(o):n.objects.push(o)}}return n},ft=(e,t,n,s,i,g)=>{const l=[];if(g.fundamental){const r=ct(e,g);for(let o=0;o<r.length;o++){const f={objects:[],partials:[]};f.objects.push(r[o]),l.push(f)}}else for(let r=0;r<(i?4:3);r++){const o={objects:[],partials:[]};if(r>=n.facets.length){l.push(o);continue}const f=n.facets[r];for(let u=0;u<f.parts.length;u++){const c=f.parts[u];let p=c.key;g.compound&&c.dual&&(e.dimensions>2?p=`${D[e.dimensions-r-1]}_${c.key.split("_").slice(-1)[0]}`:p="vertex_0-1");const h=t.get(p),{objects:d,partials:v}=c.dual?ot(r,h,e,s,c.key,g):it(r,h,g);o.objects.push(d),o.partials.push(v)}l.push(o)}return l},ut=(e,t,n,s,i)=>{if(s||n.length===0)return t.includes(e);const g=[],l=[];for(const r of n){const o=$(i,r);if(!o)return null;const f=$(i,e+r);if(!f)return null;g.push(o),l.push(f)}return g.sort((r,o)=>r-o),l.sort((r,o)=>r-o),g.every((r,o)=>r===l[o])},at=(e,t)=>{const{gens:n,localgens:s,facet:i,partial:g,rank:l}=e;let r="";for(let o=0;o<n.length;o++){const f=ut(n[o],s,i,g,t);if(f===null)return;f&&(r+=n[o])}if(t.hosotope){if(l===1)r=r.replace(t.hosotope.gen,"");else if(l===2){let o=t.coxeter[t.hosotope.index].findIndex((u,c)=>c!==t.hosotope.index&&u!==2);o<0&&(o=t.hosotope.index<t.dimensions-1?t.hosotope.index+1:0);const f=Object.entries(t.transforms).find(([u,c])=>c.includes(o))[0];r=r.replace(f,t.hosotope.gen)}}return r},Ae=(e,t,n,s,i)=>{const g=i.space.eigens.values.some(o=>o<=0),l={facets:[],infinite:g,done:!0};i.compound&&i.dual&&(i.dual=!1,Object.assign(l,Ae(e,t,n,s,i)),i.dual=!0);const r=o=>{const f=i.dual||i.fundamental?t.dimensions-o.dimensions-1:o.dimensions;o.children.forEach(r);const u=`${D[f]}_${i.dual?"dual_":i.fundamental?"fundamental_":""}${o.key}`,c=f===t.dimensions-1&&(i.dual||i.compound)||i.fundamental||!i.fundamental&&f<(s?4:3);if(o!=null&&o.new){if(l.facets[f]||(l.facets[f]={dimensions:f,processing:0,count:0,parts:[],compute:c,done:!1,dual:i.dual,fundamental:i.fundamental}),!i.compound||!i.dual){n.has(u)||n.set(u,{});const h=n.get(u);h.key||Object.assign(h,{gens:t.gens,rels:t.rels,transforms:t.transforms,key:u,localgens:o.gens,facet:o.facet,partial:!o.done,rank:f,mirrors:o.mirrors,compute:c,done:!1,count:0,dual:i.dual,compound:i.compound,space:i.space,...o.dimensions===0&&!i.fundamental?{rootVertex:i.space.rootVertex,rootNormals:i.space.rootNormals,rootVertices:i.space.rootVertices,metric:i.space.metric}:{}})}const p=i.fundamental?o.mirrors.map(()=>0):o.mirrors;l.facets[f].parts.push({key:u,coxeter:o.coxeter,stellation:o.stellation,mirrors:p,dual:i.dual,fundamental:i.fundamental,count:0,done:!1})}};return t.children.forEach(r),dt(l,t,n,i,s),l},gt=(e,t,n,s)=>{const i=s.dual&&!s.compound||s.fundamental?[...e.facets].reverse():e.facets;s.dual&&!s.compound&&s.metric.length===2&&i.push(i.shift());const g=i.filter(l=>l.compute).every(l=>l.done);e.done=!0;for(let l=0;l<i.length;l++){const r=i[l];r.done=!0,r.count=0,r.processing=0;for(let o=0;o<r.parts.length;o++){const f=r.parts[o],u=f.key,c=t.get(u);if(!(s.compound&&!c)){if(typeof c.facet=="function"&&(c.facet=c.facet(s)),c.subgens===void 0&&(c.subgens=at(c,s),c.subgens===void 0))return;!c.done&&(g||c.compute)&&(c.limit=c.compute?n:2e3,l===1&&e.infinite&&(c.limit*=1.75),c.compute?(Oe(c),f.count=c.cosets.size,f.processing=c.words.size):f.count=et(c),f.done=c.done),r.done=r.done&&f.done,r.count+=f.count,r.processing+=f.processing}}e.done=e.done&&r.done}if(s.compound)for(let l=0;l<i.length;l++){const r=i[l];for(let o=0;o<r.parts.length;o++){const f=r.parts[o],u=f.key;if(t.get(u))continue;const c=u.replace(/dual_/g,""),p=t.get(c);p&&(p.compute?(f.count=p.cosets.size,f.processing=p.words.size):f.count=p.count,f.done=p.done,r.count+=f.count,r.processing+=f.processing)}}},dt=(e,t,n,s,i)=>{const g=l=>({dimensions:l.rank,processing:1,count:0,parts:[{key:l.key,coxeter:l.coxeter,stellation:l.stellation,mirrors:l.mirrors,dual:s.dual,fundamental:s.fundamental,count:0,done:!0}],done:!0});if(t.dimensions===0){const l={...t,key:"vertex",currentWords:t.currentWords||new Map([[1,""]]),dualCurrentWords:t.dualCurrentWords||new Map([[1,""]]),subgens:t.subgens,facet:[""],rank:t.dimensions,mirrors:t.mirrors,compute:!0,done:!0,vertices:new Map([[1,[0]]])};Object.assign(s,l),n.set(l.key,l),e.facets[0]=g(l)}else if(t.dimensions===1){const l={...t,key:"edge",currentWords:t.currentWords||new Map([[1,""]]),subgens:t.subgens,facet:r=>r.words?Array.from(r.words.values()):[""],rank:t.dimensions,mirrors:t.mirrors,compute:!0,done:!0};n.set(l.key,l),e.facets[1]=g(l)}else if(t.dimensions===2){const l=o=>{if(o.fundamental)return[];const f=t.gens.split("").every(h=>t.mirrors[t.transforms[h][0]]),u=t.gens.split("").every(h=>t.transforms[h].length===2),c=Array.from(o.words.values()),p=new Array(c.length);for(let h=0;h<c.length;h++)p[h]=c[u?h:Se(h,p.length,f)];return p},r={...t,key:"face",currentWords:t.currentWords||new Map([[1,""]]),dualCurrentWords:t.dualCurrentWords||new Map([[1,""]]),subgens:t.subgens,facet:l,rank:t.dimensions,mirrors:t.mirrors,compute:!0,done:!0};n.set(r.key,r),e.facets[2]=g(r)}else if(t.dimensions===3&&i){const l={...t,key:"cell",currentWords:t.currentWords||new Map([[1,""]]),dualCurrentWords:t.dualCurrentWords||new Map([[1,""]]),subgens:t.subgens,facet:r=>Array.from(r.words.values()),rank:t.dimensions,mirrors:t.mirrors,compute:!0,done:!0};n.set(l.key,l),e.facets[3]=g(l)}};let H,C,S,_,E,R;onmessage=({data:{type:e,space:t,dimensions:n,coxeter:s,stellation:i,mirrors:g,ambiance:l,batch:r,hidden:o,reciprocation:f,extrarels:u,section:c,iteration:p}})=>{try{if(p<0&&(S=oe(n,s,i,g,t,u),C={space:t,fundamental:g.length&&g.every(a=>!a),dual:g.some(a=>Pe(a)),compound:g.some(a=>Ge(a)),lasts:new Array(3).fill(0),subgens:S.subgens,hosotope:S.hosotope,coxeter:S.coxeter},H=new Map([[`${D[C.dual&&!C.compound||C.fundamental?n-1:0]}_${C.dual&&!C.compound?"dual_":C.fundamental?"fundamental_":""}${S.root.key}`,C]]),_=Ae(r,S,H,c,C),E=[],R=[],Object.assign(self,{shape:S,polytope:_,fullObjects:E,fullRawObjects:R,tcParams:H,root:C})),e==="paint"){const a=Y(S.dimensions,E,l,o);postMessage({color:a},a.data.filter(m=>m).map(m=>m.buffer));return}if(e==="section"){if(!R.length)return;let a=R;c!==null&&(a=Ve(a,c,C)),C.fundamental||(a[2]=_e(a[2],C)),E=a;const m=ue(S.dimensions,a,o),j=Y(S.dimensions,a,l,o);postMessage({geometry:m,color:j},m.data.flat(1).concat(j.data).filter(y=>y).map(y=>y.buffer));return}if(e==="display"){const a=ue(S.dimensions,E,o),m=Y(S.dimensions,E,l,o);postMessage({geometry:a,color:m},a.data.flat(1).concat(m.data).filter(j=>j).map(j=>j.buffer));return}e==="iterate"&&gt(_,H,r,C);let h=ft(S,H,_,f,c,C);if(c)for(let a=0;a<h.length;a++){const m=h[a];R[a]||(R[a]={objects:[],partials:[]}),R[a].objects.push(...m.objects),R[a].partials=m.partials}c!==null&&(h=Ve(h,c,C)),C.fundamental||(h[2]=_e(h[2],C));for(let a=0;a<h.length;a++){const m=h[a];E[a]||(E[a]={objects:[],partials:[]}),E[a].objects.push(...m.objects),E[a].partials=m.partials}const d=ue(S.dimensions,h,o,C.lasts),v=Y(S.dimensions,h,l,o,C.lasts);C.lasts=d.infos.map(a=>a.start+a.nonpartial),_.gens=S.gens,_.subgens=S.subgens,_.rels=S.rels,_.transforms=S.transforms,_.extrarels=S.extrarels,_.fundamental=C.fundamental,_.dual=C.dual,_.compound=C.compound,_.size=C.fundamental?C.words.size:C.vertices.size,postMessage({polytope:_,geometry:d,color:v},d.data.flat(1).concat(v.data).filter(a=>a).map(a=>a.buffer))}catch(h){postMessage({error:h.message})}}})();
