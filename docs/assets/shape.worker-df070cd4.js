(function(){"use strict";const{abs:H,cos:ot,sin:it,tan:ct,cosh:lt,sinh:ft,acos:ut,acosh:gt,atan:dt,atan2:ht,min:at,max:vt,round:Ve,sqrt:ce,cbrt:mt,sign:bt,ceil:wt,floor:xt,log:jt,exp:kt,hypot:zt,pow:Se,PI:Vt}=Math,Ce=(...e)=>e.reduce((n,t)=>n+t,0)/e.length,le=new ArrayBuffer(8),Ae=new Float64Array(le),fe=new Int32Array(le);function Oe(e){return~~e===e?~~e:(Ae[0]=e,fe[0]^fe[1])}const ue=10**4,ge=e=>{let n="";for(let t=0;t<e.length;t++)n+=Oe(Ve(e[t]*ue)/ue).toString(),t<e.length-1&&(n+="|");return n},Me=e=>e.sort((n,t)=>{for(let s=0;s<n.length;s++){if(n[s]<t[s])return-1;if(n[s]>t[s])return 1}return 0}),B=e=>Me(e).map(n=>ge(n)).join("-"),y=e=>String.fromCharCode(97+e),de=e=>e.charCodeAt(0)-97,$=e=>{const n=e.toUpperCase();return e===n?e.toLowerCase():n},he=(e,n=null,t=1,s=!1)=>{if(n===null&&(n=e,e=0),t===0)throw new Error("Step cannot be zero.");if(n<e&&t>0||n>e&&t<0){if(s)return[];t=-t}return new Array(Math.ceil((n-e)/t)).fill().map((c,m)=>e+m*t)},D=(e,n)=>e.length!==n.length?!1:e.every((t,s)=>Array.isArray(t)?D(t,n[s]):t===n[s]),Ee=e=>e==="m"||e==="b"||e==="c"||e==="d",We=e=>e==="c"||e==="d",_=e=>e==="s"||e==="b"||e==="d",N=(e,n)=>{let t=0;for(let s=0;s<e.length;s++)t+=e[s]*n[s];return t},Ie=(e,n)=>[e[1]*n[2]-e[2]*n[1],e[2]*n[0]-e[0]*n[2],e[0]*n[1]-e[1]*n[0]],L=(e,n)=>{const t=[];for(let s=0;s<e.length;s++)t[s]=e[s]+n[s];return t},p=(e,n)=>{const t=[];for(let s=0;s<e.length;s++)t[s]=e[s]-n[s];return t},E=(e,n)=>{const t=[];for(let s=0;s<e.length;s++)t[s]=e[s]*n;return t},ee=e=>{const n=[];for(let t=0;t<e[0].length;t++){n.push([]);for(let s=0;s<e.length;s++)n[t].push(e[s][t])}return n},U=(e,n)=>{const t=new Array(e.length);for(let s=0;s<e.length;s++){let c=0;for(let m=0;m<e[0].length;m++)c+=e[s][m]*n[m];t[s]=c}return t},$e=e=>{const n=new Array(e.length);for(let t=0;t<e.length;t++)n[t]=new Array(e.length).fill(0),n[t][t]=e[t];return n},R=e=>{const n=new Array(e).fill(1);return $e(n)},te=(e,n)=>e.filter((t,s)=>!n.includes(s)),ae=(e,n)=>te(e,n).map(t=>te(t,n)),G=(e,n,t)=>p(e,E(U(Fe(t),n),2*N(U(Pe(t),e),n))),Z=(e,n)=>{if(n.some((s,c)=>s.some((m,f)=>c===f&&m===0)))return e[e.length-1]===0&&(e[e.length-1]=1e-16),E(e,1/e[e.length-1]);let t=N(U(n,e),e);return t===0&&(t=1e-16),E(e,-1/ce(H(t)))},_e=1,Pe=e=>e.map((n,t)=>n.map((s,c)=>t===c&&s===0?_e:s)),Fe=e=>e.map(n=>n.map(t=>H(t))),Ne=e=>{const n=[];for(let f=0;f<e.length;f++)for(let l=f+1;l<e.length;l++)e[f][l]!==2&&n.push([f,l]);if(n.length!==e.length-1)return;const t=new Array(e.length).fill(0);if(n.forEach(([f,l])=>{t[f]++,t[l]++}),t.some(f=>f>3)||t.filter(f=>f===1).length!==2)return;const c=[t.indexOf(1)],m=[];for(let f=0;f<e.length-1;f++){const l=c[c.length-1],i=n.findIndex(d=>d.includes(l));let r=n[i];n.splice(i,1),r[0]===l&&r.reverse(),c.push(r[0]),m.push(r.reverse())}return{group:c,pairs:m}},Re=e=>{const n=new Array(e.length).fill(0);for(let c=0;c<e.length;c++)for(let m=c+1;m<e.length;m++)e[c][m]!==2&&(n[c]++,n[m]++);if(n.filter(c=>c===3).length!==1||n.filter(c=>c===1).length!==e.length-1)return;const t=n.indexOf(3),s=n.map((c,m)=>[m,t]).filter(([c,m])=>c!==m);return{group:[t],pairs:s}},Ge=e=>{const n=Ne(e);if(n)return{type:"c",description:"C-Group",...n};const t=Re(e);return t?{type:"star",description:"Star Group",...t}:{type:"other",description:"Other Group"}},ne=(e,n="",t=[])=>{const s=[];for(let c=0;c<e.length;c++){const[m,f]=e[c],l=e.filter((i,r)=>r!==c);if(t.length){const i=t[t.length-1];if(f.some(r=>r===i)){const r=f[1]===i,d=r?m.toUpperCase():m,g=r?[...f].reverse():f;if(g[1]===t[0])return[n+d];l.length&&s.push(...ne(l,n+d,t.concat(g.slice(1))))}}else s.push(...ne(l,m,f))}return s},Te=(e,n)=>{var i,r;const t=[],s=Object.entries(e),c=s.filter(([d,g])=>g.length===1),m=s.filter(([d,g])=>g.length===2),f=s.filter(([d,g])=>g.length===3),l=Object.fromEntries(c.map(([d,g])=>[g[0],d]));for(let d=0;d<s.length;d++){const[g,h]=s[d];if([1,3].includes(h.length)&&t.push(g.repeat(2)),h.length===2){const u=n[h[0]][h[1]];u>1&&t.push(g.repeat(u))}if(h.length===1){const u=h[0];for(let o=0;o<c.length;o++){const[v,a]=c[o];if(a>u){const b=n[u][a];b>1&&t.push((g+v).repeat(b))}}}if(h.length===3){const u=n[h[0]][h[1]];if(u>1){const o=l[h[1]];o?t.push((g+o).repeat(u%2===0?u/2:u)):console.warn("No conjugate conjugate reflection",g,h)}for(let o=0;o<f.length;o++){const[v,a]=f[o];if(a[1]===h[1]&&a[0]>h[0]){let b=(i=m.find(([k,w])=>w[0]===h[0]&&w[1]===a[0]))==null?void 0:i[0];b||(b=$((r=m.find(([k,w])=>w[1]===h[0]&&w[0]===a[0]))==null?void 0:r[0])),b&&t.push($(g)+$(b)+v+b)}if(a[0]===h[0]&&a[1]>h[1]){const b=n[h[1]][a[1]];b>1&&t.push((g+v).repeat(b))}}}}if(m.length>1){const d=ne(m);t.push(...d.map(g=>g.split("").reverse().join("")))}return t},qe=(e,n,t)=>{const s=[];if(n.length>2&&n.length<6&&t.some((l,i)=>l.some((r,d)=>r>1&&n[i][d]>1))){const l=Ge(n);l.type==="c"?s.push(...ye(n,t,l.group,l.pairs)):l.type==="star"&&s.push(...He(n,t,l.group,l.pairs))}n.length===3&&n[0][1]===5&&n[0][2]===3&&n[1][2]===5&&(t[0][1]===3&&t[0][2]===1&&t[1][2]===1||t[0][1]===1&&t[0][2]===1&&t[1][2]===3)&&s.push(T(2,[0,1,2,1]));const c=Object.fromEntries(Object.entries(e).filter(([l,i])=>i.length===1).map(([l,i])=>[i[0],l])),m=Object.entries(e).filter(([l,i])=>i.length===2).map(([l,i])=>[[i,l],[[...i].reverse(),$(l)]]).flat(),f=[];for(let l=0;l<s.length;l++){const i=s[l];let r="",d=!1;for(let g=0;g<i.length;g++){const h=i[g],u=c[h];if(u)r+=u;else{const o=m.find(([v,a])=>v[0]===h&&g<i.length-1&&v[1]===i[g+1]);if(o)r+=o[1],g++;else{d=!0;break}}}d||f.push(r)}return n.length===3&&e.a.length===2&&e.b.length===3&&e.c.length===3&&n[0][1]!==2&&n[1][2]===3&&f.push("abcb".repeat(2)),n.length===3&&e.a.length===1&&e.b.length===3&&e.c.length===3&&n[1][2]!==2&&n[0][1]===3&&f.push("dcbc".repeat(2)),f},T=(e,n)=>Array(e).fill(n).flat(),ye=(e,n,t,s)=>{const c=[];if(!s.filter(([u,o])=>n[u][o]>1).map(([u,o])=>e[u][o]===5))return c;const f=s.map(([u,o])=>e[u][o]);if(f.filter(u=>u!==3&&u!==5).length>(e.length===3?0:1))return c;if(f.filter(u=>u!==3&&u!==5).length===1){const u=f.findIndex(o=>o!==3&&o!==5);if(![0,f.length-1].includes(u))return c}const l=[f,[...f].reverse()],i=s.map(([u,o])=>n[u][o]),r=[i,[...i].reverse()],d=({m:u,s:o})=>{if(u.length!==e.length-1)return!1;for(let v=0;v<l.length;v++){const a=l[v],b=r[v];if(a.every((k,w)=>k===u[w]||u[w]===null)&&b.every((k,w)=>k===o[w]||o[w]===null))return!0}};if(d({m:[null,5,5],s:[null,1,2]})&&(f[i[0]===2?f.length-1:0]=0),[{m:[null,3,5,5],s:[null,1,1,2]},{m:[null,5,5,5],s:[null,1,2,1]},{m:[null,5,3,5],s:[null,1,1,2]}].some(d)||(d({m:[5,5,5,3],s:[1,1,2,1]})&&(f[i[1]===2?f.length-1:0]=0),f.filter(u=>u===3).length>e.length-3))return c;const g=[];let h=[];for(let u=0;u<f.length;u++)f[u]===5&&(h.length?(h.push(u),g.push(h),h=[u]):h.push(u));for(let u=0;u<g.length;u++){const[o,v]=g[u],a=[];for(let b=o;b<v+2;b++)a.push(t[b]);a.push(...a.slice(1,a.length-1).reverse()),c.push(T(3,a))}return c},He=(e,n,t,s)=>{const c=[];if(e.length!==4||!s.filter(([r,d])=>n[r][d]>1).map(([r,d])=>e[r][d]===5))return c;const f=s.map(([r,d])=>e[r][d]);if(f.find(r=>r!==3&&r!==5)||f.filter(r=>r===3).length!==1)return c;const l=s[f.findIndex(r=>r===3)],i=s.filter(([r,d])=>e[r][d]===5);return c.push(T(3,[...i[0],...i[1]])),c.push(T(2,[...T(3,[i[1][0],...l].reverse()),...T(2,[...i[0]].reverse())])),c},Be=e=>{for(e=e.replace(/\s/g,""),e=e.replace(/(\w)(\^-?\d+)/g,"($1)$2");;){let n=e.replace(/\((\w+)\)\^(-?\d+)/g,(t,s,c)=>(c=parseInt(c),c<0&&(s=s.split("").reverse().map(m=>$(m)).join(""),c=-c),s.repeat(c)));if(n===e)break;e=n}return e},ve=e=>{for(e=e.replace(/\s/g,"");;){let n=e.replace(/(\w+)(\1)+/g,(t,s)=>{const c=t.length/s.length;return`(${s})^${c}`});if(n=n.replace(/\(\((\w+)\)\^(\d+)\)\^(\d+)/g,(t,s,c,m)=>`(${s})^${parseInt(c)*parseInt(m)}`),n=n.replace(/\((\w+)\)\^(\d+)(\1)/g,(t,s,c)=>`(${s})^${parseInt(c)+1}`),n=n.replace(/(\w+)\(\1\)\^(\d+)/g,(t,s,c)=>`(${s})^${parseInt(c)+1}`),n===e)break;e=n}return e=e.replace(/\(([A-Z]+)\)\^(\d+)/g,(n,t,s)=>(t=t.split("").reverse().map(c=>$(c)).join(""),`(${t})^-${s}`)),e=e.replace(/([A-Z]+)/g,(n,t)=>(t=t.split("").reverse().map(s=>$(s)).join(""),`(${t})^-1`)),e=e.replace(/\((\w)\)(\^-?\d+)/g,"$1$2"),e};typeof window<"u"&&(window.factor=ve);const M=(e,n)=>{let t=n,s=0;for(;e.quotientMap[t];)s++,t=e.quotientMap[t];return s>1&&(e.quotientMap[n]=t),t},me=(e,n,t)=>{const s=n,c=[[n,t]];for(;c.length>0;)if([n,t]=c.pop(),n>t&&([n,t]=[t,n]),n=M(e,n),t=M(e,t),n!==t){e.quotientMap[t]=n,e.seen.has(t)&&!e.seen.has(n)&&e.seen.add(n);const m=e.cosets.get(n),f=e.cosets.get(t);e.cosets.delete(t);for(const[l,i]of f)m.has(l)?c.push([m.get(l),i]):m.set(l,i)}return M(e,s)},be=(e,n,t,s)=>{n=M(e,n);const c=e.cosets.get(n);c.has(t)?me(e,c.get(t),s):c.set(t,s)},J=(e,n,t,s)=>{n=M(e,n);let c;const m=e.cosets.get(n);return m.has(t)?(c=M(e,m.get(t)),s!==void 0&&c!==s&&me(e,s,c)):(s?c=s:(c=e.nextVertex++,e.cosets.set(c,new Map),e.unvisited.push(c)),be(e,n,t,c),be(e,c,$(t),n)),c},we=function(e,n,t){let s=t;for(let c=n.length-1;c>0;c--)s=J(e,s,n[c]);J(e,s,n[0],t)},De=function(e){if(!e.words){const t=M(e,1);e.words=new Map,e.words.set(t,""),e.currentWords=new Map,e.currentWords.set(t,""),e.lastCoset=t,e.remaining=[t],e.rootVertex&&e.rootNormals&&e.metric&&(e.vertices=new Map,e.vertices.set(t,e.rootVertex))}const n=new Set;for(;e.remaining.length>0;){const t=e.remaining[0],s=M(e,t),c=e.cosets.get(s),m=e.words.get(s);if(m===void 0){if(n.has(t)){console.warn("Failed to find word for coset",t);return}e.remaining.push(e.remaining.shift()),n.add(t);continue}if(c.size<e.gens.length*2)return;const f=[];for(let l=0;l<e.gens.length;l++){const i=e.gens[l],r=M(e,c.get(i));if(!e.words.has(r)){if(e.cosets.get(r).size<e.gens.length*2)return;f.push([i,r])}}e.remaining.shift();for(let l=0;l<f.length;l++){const[i,r]=f[l],d=i+m;if(e.words.set(r,d),e.currentWords.set(r,d),e.lastCoset=r,e.remaining.push(r),e.vertices){let g=e.vertices.get(s);for(let h=0;h<e.transforms[i].length;h++){const u=e.transforms[i][h];g=G(g,e.rootNormals[u],e.metric)}e.vertices.set(r,g)}}}},I=(e,n)=>{let t=M(e,1);for(let s=n.length-1;s>=0;s--){const c=e.cosets.get(t);if(c.size<e.gens.length*2||(t=M(e,c.get(n[s])),e.cosets.get(t).size<e.gens.length*2))return}return t},xe=e=>{if(e.cosets)e.unvisited.splice(0,e.pointer),e.pointer=0;else{e.unvisited=[1],e.pointer=0,e.cosets=new Map([[1,new Map]]),e.nextVertex=2,e.seen=new Set,e.quotientMap={};for(let n=0;n<e.subgens.length;n++)we(e,e.subgens[n],1)}e.limit=e.limit||1e3,e.done=!1;for(let n=0;n<e.limit;n++){let t=null;for(;e.unvisited.length-e.pointer>0;){const s=e.unvisited[e.pointer++],c=M(e,s);if(!e.seen.has(c)){e.seen.add(c),t=c;break}}if(t===null){e.done=!0;break}for(let s=0;s<e.gens.length;s++)J(e,t,e.gens[s].toUpperCase()),J(e,t,e.gens[s]);for(let s=0;s<e.rels.length;s++)we(e,e.rels[s],t)}},Le=e=>(xe(e),e.cosets.size),je=e=>(xe(e),De(e),e),ke=(e,n,t)=>{if(t){n%2&&n--;const s=e>0?1-e%2:0;return e>=n/2+s?2*(n-e)-1+s:2*e-s}return e>=n/2?2*(n-e)-1:2*e},Ue=(e,n,t)=>{if(n===0)return!0;if(e.length<=n)return!1;const s=new Set;for(let c=0;c<e.length;c++){const m=e[c];if(m)for(let f=0;f<m.length;f++){const l=m[f];for(let i=0;i<t[l].length;i++){const r=y(t[l][i]);s.has(r)||s.add(r)}if(s.size>=n)return!0}}return!1},se=(e,n,t,s,c,m,f=null,l=null)=>{if(!f){s.every(o=>!o)&&(s=s.map(()=>1));let r="",d=0;const g={};for(let o=0;o<e;o++){if(!_(s[o])){const v=y(d++);r+=v,g[v]=[o]}for(let v=o+1;v<e;v++)if(_(s[o])&&_(s[v])){const a=y(d++);r+=a,g[a]=[o,v]}else if(_(s[o])&&!_(s[v])){const a=y(d++);r+=a,g[a]=[o,v,o]}else if(!_(s[o])&&_(s[v])){const a=y(d++);r+=a,g[a]=[v,o,v]}}const h=Object.entries(g).filter(([o,v])=>v.every(a=>!s[a])).map(([o])=>o).join(""),u=Te(g,n);if(m){const o=m.split(",");for(let v=0;v<o.length;v++){let a=o[v];a=a.replace(/\s/g,""),a&&(a=Be(a),a.split("").every(b=>r.includes(b.toLowerCase()))&&u.push(a))}}else{const o=qe(g,n,t);u.push(...o),m=o.map(v=>ve(v)).join(", ")}if(f={new:!0,key:"",dimensions:e,coxeter:n,stellation:t,mirrors:s,gens:r,subgens:h,transforms:g,rels:u,extrarels:m,facet:[""],removed:[],children:[]},l=f,l.solved=new Map,s.length>1&&s.filter(o=>o).length===1){const o=s.findIndex(v=>v);if(n[o].every((v,a)=>o===a||v===2)){const v=o===e-1?e-2:o+1,[a]=Object.entries(f.transforms).find(([b,k])=>k.includes(v));l.hosotope={gen:a,index:v}}}}const i=[];for(let r=0;r<e;r++){if(f.removed.includes(r))continue;let d=f.gens.split("").filter(a=>!f.transforms[a].includes(r)).join("");const g=[...f.removed,r],h=g.sort().join("-");let u=!1;if(!l.solved.has(h)){u=!0;const a={dimensions:f.dimensions-1,coxeter:ae(l.coxeter,g),stellation:ae(l.stellation,g),mirrors:te(l.mirrors,g),gens:d,subgens:l.subgens.split("").filter(b=>d.includes(b)).join(""),rels:l.rels.filter(b=>b.toLowerCase().split("").every(k=>d.includes(k))),transforms:Object.fromEntries(Object.entries(f.transforms).filter(([b])=>d.includes(b))),removed:g,key:h,limit:c.curvature>0?2500:1e3};je(a),a.facet=Array.from(a.words.values()),l.solved.set(h,a)}const o=l.solved.get(h),v=l.hosotope&&o.removed.length&&o.removed[0]===l.hosotope.index&&o.removed.every((a,b)=>b===0||a===(o.removed[b-1]+1)%e);if(Ue(o.facet,o.dimensions,l.transforms)||v){if(u&&o.dimensions===2){const b=[...o.facet],k=o.gens.split("").every(x=>l.mirrors[l.transforms[x][0]]),w=o.gens.split("").every(x=>l.transforms[x].length===2);for(let x=0;x<b.length;x++)o.facet[x]=b[w?x:ke(x,o.facet.length,k)]}const a={new:u,children:[],...o};a.removed.length<e?f.children.push(se(e,n,t,s,c,m,a,l)):f.children.push(a)}else i.push(o)}if(f.children.length===0&&f.dimensions>0){console.debug("No leaf found, digging deeper",f.gens);for(let r=0;r<i.length;r++){const d=i[r],g={new:!1,children:[],...d};g.removed.length<e?f.children.push(se(e,n,t,s,c,m,g,l)):f.children.push(g)}}if(f===l&&s.some(r=>_(r))){let r="",d=[];for(let g=1;g<e;g++)if(g===1){const h=[],u=w=>{w.dimensions===1?w.new&&h.push(w):w.children.forEach(u)};u(f);const o=Object.entries(l.transforms).filter(([w,x])=>x.length!==1||s[x[0]]).filter(([w,x])=>x.length!==3||n[x[0]][x[1]]!==2).map(([w])=>w);for(let w=0;w<h.length;w++){const x=h[w];o.includes(x.gens)&&o.splice(o.indexOf(x.gens),1)}const v=d;d=[];const a=R(1).map((w,x)=>w.map((V,j)=>x===j?1:x===j+1||x===j-1?4:2)),b=R(1).map(w=>w.map(()=>1)),k=he(1).map(()=>"s");for(let w=0;w<o.length;w++){const x=o[w],V={dimensions:1,coxeter:a,stellation:b,mirrors:k};V.gens=x;const j={new:!0,done:!0,key:`se-${x}`,...V,facet:["",x],children:w===0?v:[]};d.push(j)}}else if(g===2){const h=V=>R(2).map((j,z)=>j.map((A,S)=>z===S?1:z===S+1||z===S-1?V:2)),u=V=>R(2).map(j=>j.map(()=>V)),o={},v=Object.entries(l.transforms).filter(([V,j])=>j.length===2),a=Object.entries(l.transforms).filter(([V,j])=>j.length===3);let b="";const k=V=>{V.dimensions===2?V.new&&V.gens.length===1&&(b+=V.gens):V.children.forEach(k)};k(f),r+=b;for(let V=0;V<v.length;V++){const[j,z]=v[V];for(let A=V+1;A<v.length;A++){const[S,C]=v[A];z[z.length-1]===C[C.length-1]&&(o[j+S]={facet:["",j,S]},r+=j+S)}}for(let V=0;V<a.length;V++){const[j,z]=a[V];for(let A=V+1;A<a.length;A++){const[S,C]=a[A];if(z[0]===C[0]&&n[z[1]][C[1]]!==2&&(n[z[1]][z[0]]!==2||n[z[0]][C[1]]!==2)){const P=n[z[1]][C[1]],F=s[C[1]]||n[z[0]][C[1]]!==2,X=[];for(let Y=0;Y<P;Y++)F&&X.push(j+(S+j).repeat(P-Y)),X.push((S+j).repeat(Y));o[j+S]={facet:X,snubCoxeter:h(X.length),snubMirrors:["s",F?1:0]},r+=j+S}}for(let A=0;A<v.length;A++){const[S,C]=v[A];z[0]===C[1]&&(n[z[1]][C[0]]!==2||n[z[1]][C[1]]!==2||s[z[1]])&&(s[z[1]]||n[z[1]][C[0]]!==2&&n[z[1]][C[1]]!==2?o[j+S]={facet:["",j,j+S,S],snubCoxeter:h(4)}:n[z[1]][C[0]]!==2?o[j+S]={facet:["",S,j+S]}:o[j+S]={facet:["",j,S]},r+=j+S)}}const w=d;d=[],Object.keys(o).length||(o[""]={facet:[""]});const x=Object.entries(o);for(let V=0;V<x.length;V++){const[j,{facet:z,snubCoxeter:A,snubStellation:S,snubMirrors:C}]=x[V],P={dimensions:2,coxeter:A||h(3),stellation:S||u(1),mirrors:C||["s","s"]};P.gens=j;const F={new:z.length!==1,done:!0,key:`sf-${j}`,...P,facet:z,children:V===0?w:[]};d.push(F)}}else{const h=R(g).map((k,w)=>k.map((x,V)=>w===V?1:2)),u=R(g).map(k=>k.map(()=>1)),o=he(g).map(()=>"s"),v=d;d=[];let a=r;const b={new:!0,done:!0,key:`s${g}`,gens:f.gens.split("").filter(k=>!a.includes(k)).join(""),dimensions:g,coxeter:h,stellation:u,mirrors:o,facet:[],children:v};d.push(b)}f.children.push(...d)}return f},q=["vertex","edge","face"],re=(e,n,{p:t,normal:s})=>{const c=N(p(t,e),s)/N(p(n,e),s);if(c<0||c>1)return;const m=[];for(let f=0;f<e.length;f++)m.push(e[f]+c*(n[f]-e[f]));return m},Ze=(e,n,t,s)=>{const c=[],m=[];if(e===0)for(let f=0;f<t.length;f++){const l=t[f],{vertices:i,partial:r}=l,d=re(i[0],i[1],n);if(!d)continue;const g={...l,vertices:[d]};r?m.push(g):c.push(g)}else if(e===1){s.root.crossEdges||(s.root.crossEdges=new Map);for(let f=0;f<t.length;f++){const l=t[f],i=[],r=[];for(let g=0;g<l.vertices.length;g++){const h=l.vertices[g],u=l.vertices[(g+1)%l.vertices.length],o=re(h,u,n);o&&(r.push(B([h,u])),i.push(o))}if(i.length<2)continue;if(!l.partial)for(let g=0;g<2;g++)s.root.crossEdges.has(r[g])?s.root.crossEdges.get(r[g]).add(r[(g+1)%2]):s.root.crossEdges.set(r[g],new Set([r[(g+1)%2]]));const d={...l,vertices:i};l.partial?m.push(d):c.push(d)}}else if(e===2){s.root.unfinishedCells||(s.root.unfinishedCells=new Map);const f=[...t,...Array.from(s.root.unfinishedCells.values())];for(let l=0;l<f.length;l++){const i=f[l],r=[],d=[];for(let a=0;a<i.vertices.length;a++)for(let b=a+1;b<i.vertices.length;b++){const k=B([i.vertices[a],i.vertices[b]]);if(s.root.crossEdges.has(k)){const w=re(i.vertices[a],i.vertices[b],n);if(!w)continue;d.push([k,s.root.crossEdges.get(k)]),r.push(w)}}if(r.length<3){!s.root.unfinishedCells.has(i.word)&&!i.partial&&s.root.unfinishedCells.set(i.word,i);continue}const g=[0];let h=d[0][1];for(let a=0;a<d.length;a++)for(let b=0;b<d.length;b++)if(!g.includes(b)&&h.has(d[b][0])){g.push(b),h=d[b][1];break}let u=i.partial;g.length<r.length?(u=!0,!s.root.unfinishedCells.has(i.word)&&!i.partial&&s.root.unfinishedCells.set(i.word,i)):s.root.unfinishedCells.delete(i.word);const o=[];for(let a=0;a<g.length;a++)o.push(r[g[a]]);const v={...i,vertices:o,partial:u};u?m.push(v):c.push(v)}}return{sections:c,sectionPartials:m}},Je=(e,n,t,s)=>{const c=t.slice(0,-1),m=t[t.length-1],f=E(c,1/ce(N(c,c))),i={p:E(f,m),normal:f},r=[];for(let d=0;d<3;d++){const g=n[d+1];if(!g){r.push(null);continue}const h={start:e.root.lasts[d],size:0,objects:[],partials:[]},u=g.objects.concat(g.partials);for(let o=0;o<u.length;o++){const v=u[o]||[],{sections:a,sectionPartials:b}=Ze(d,i,v,e);s[q[d]]&&(h.objects.push(a),h.size+=a.length+b.length,h.partials.push(b))}r.push(h)}return r},oe=(e,n,t)=>(t<0&&(t+=1),t>1&&(t-=1),t<1/6?e+(n-e)*6*t:t<1/2?n:t<2/3?e+(n-e)*(2/3-t)*6:e),O=(e,n,t)=>{let s,c,m;if(n===0)s=c=m=t;else{const f=t<.5?t*(1+n):t+n-t*n,l=2*t-f;s=oe(l,f,e+1/3),c=oe(l,f,e),m=oe(l,f,e-1/3)}return[s,c,m]},K=[[10/360,.56,.91],[0/360,.59,.88],[316/360,.72,.86],[267/360,.84,.81],[343/360,.81,.75],[350/360,.65,.77],[23/360,.92,.75],[41/360,.86,.83],[115/360,.54,.76],[170/360,.57,.73],[189/360,.71,.73],[199/360,.76,.69],[217/360,.92,.76],[232/360,.97,.85]],Ke={background:[0,0,0,1],glow:!1,shading:"ads",diffuse:"lambert",specular:!1,shininess:32,opacity:1,ambient:.2,roughness:.85,gouraud:!1,transparency:"oit",color:({word:e})=>O(e.length*.03%1,.75,.7)},Qe=Object.fromEntries(Object.entries({neon:{background:[0,0,0,1],glow:{exposure:1.75,strength:2,offset:{up:2,down:2},steps:3,pow:2},shading:!1,face:{opacity:.025},transparency:"blend",color:({word:e,dual:n})=>O((e.length*.17-(n?.43:0))%1,.5,.6)},disco:{background:[0,0,0,1],glow:{exposure:1.5,strength:2,offset:{up:2,down:2},steps:4,pow:2},face:{gouraud:!0,diffuse:"fresnel",opacity:.025},transparency:"blend",color:({word:e})=>O(...K[e.length%K.length])},cathedral:{background:[.6,.6,.6,1],glow:{exposure:1.5,strength:2,offset:{up:2,down:2},steps:4,pow:2},shading:!1,face:{opacity:.9},transparency:"oit",color:({word:e,subShape:n,type:t})=>t==="face"?O((n*.23+e.length*.07)%1,1,.58):[0,0,0]},synthwave:{background:[...O(.77,.6,.04),1],glow:{exposure:1.5,strength:3,offset:{up:3,down:3},steps:3,pow:2},shading:!1,face:{opacity:.015},afterImage:.7,transparency:"blend",color:({word:e})=>O((.5-e.length*.05%.5+.65)%1,.4,.6)},colorful:{background:[1,1,1,1],diffuse:"oren-nayar",specular:"cook-torrance",shininess:32,opacity:1,ambient:.2,gouraud:!1,face:{gouraud:!0,opacity:.1,diffuse:"fresnel",specular:!1},transparency:"oit",color:({word:e,dual:n})=>O(e.length*.03%1-(n?.25:0),1,.8)},shiny:{background:[0,0,0,1],diffuse:"lambert",specular:"blinn-phong",shininess:32,opacity:1,ambient:.2,gouraud:!1,face:{gouraud:!0,opacity:.1,diffuse:"fresnel",specular:!1},transparency:"oit",color:({word:e})=>O(-(e.length*.07)%1,1,.8)},flare:{background:[1,1,1,1],transparency:"blend",diffuse:"cel",face:{opacity:.6,gouraud:!1},color:({word:e})=>O(e.length*.09%1,1,.8)},shape:{background:[1,1,1,1],transparency:"oit",face:{gouraud:!0,opacity:.2,diffuse:"fresnel"},color:({subShape:e,type:n})=>n!=="vertex"?O(e*.21%1,1,.8):[1,1,1]},reflection:{background:[1,1,1,1],transparency:"blend",diffuse:"cel",face:{opacity:.6,gouraud:!1},color:({word:e,type:n,dimensions:t,draw:s})=>{const c=e.length?de(e[e.length-1])/t:0;return O(c%1,1,n==="face"?.6:s.face?0:.8)}},harlequin:{background:[...O(240/360,.23,.09),1],face:{opacity:.6},transparency:"oit",color:({word:e,idx:n,type:t})=>{const s=e.split("").map(m=>de(m)).reduce((m,f)=>m+f,0),c=[...K[s%K.length]];return n%2&&(c[2]*=.5),O(...c)}},pure:{background:[0,0,0,1],color:({word:e})=>O(e.length*.03%1,.75,.7)},facets:{background:[0,0,0,1],color:({faceIndex:e,faceSize:n})=>O((e||0)/(n||1),.75,.7)},monochrome:{background:[.12,.12,.12,1],diffuse:"reverse",ambient:0,face:{opacity:.1},transparency:"oit",color:()=>[1,1,1]},glass:{background:[0,0,0,1],transparency:"blend",opacity:.2,ambient:0,diffuse:"fresnel",specular:"blinn-phong",face:{shininess:16,diffuse:!1},color:({subShape:e,word:n,type:t})=>t!=="vertex"?O((e*.21+n.length*.03)%1,1,.8):[1,1,1]},plain:{extended:!0,background:[1,1,1,1],glow:!1,shading:!1,color:({word:e,type:n,draw:t})=>O(e.length*.06%1,1,n==="face"?.6:t.face?.05:.5)},plainblack:{extended:!0,background:[1,1,1,1],shading:!1,color:({word:e,type:n})=>n==="face"?new Array(3).fill(1-Se(.9,e.length+1)):[0,0,0]},normals:{extended:!0,background:[1,1,1,1],shading:"normal",color:()=>[0,0,0]},uvs:{extended:!0,background:[1,1,1,1],shading:"uv",color:()=>[0,0,0]}}).map(([e,n])=>[e,{...Ke,...n,transparent:{}}])),Xe=e=>e>4?9:e<1?1:e,Ye=(e,n,t,s)=>{const c=[],m=[],f=Xe(e);for(let l=0;l<n.length;l++){const i=n[l];if(!i){c.push(null),m.push(null);continue}const r=[new Float32Array(i.size*3)];for(let h=0;h<l+1;h++)r.push(new Float32Array(i.size*f));let d=0;const g=i.objects.concat(i.partials);for(let h=0;h<g.length;h++){const u=g[h];if(u)for(let o=0;o<u.length;o++){const v=u[o];for(let b=0;b<v.vertices.length;b++){const k=v.vertices[b];for(let w=0;w<k.length;w++)r[b+1][d*f+w]=k[w]}const a=Qe[t].color({word:v.word,key:v.key,subShape:h%i.objects.length,faceIndex:v.faceIndex,faceSize:v.faceSize,dimensions:e,draw:s,idx:d,size:i.size,type:q[l],dual:!!v.dual});r[0][d*3+0]=a[0],r[0][d*3+1]=a[1],r[0][d*3+2]=a[2],d++}}c.push(r),m.push({start:i.start,size:i.size})}return{infos:m,data:c}},pe=(e,n,t,s)=>{const c=[],m=[];if(e===0)for(const[f,l]of n.currentWords)c.push({word:l,vertices:[n.vertices.get(f)]}),n.currentWords.delete(f);else if(e===1)for(const[f,l]of n.currentWords){const i={word:l,vertices:[]};for(let r=0;r<n.facet.length;r++){const d=I(s.root,l+n.facet[r]);d&&s.root.vertices.has(d)&&i.vertices.push(s.root.vertices.get(d))}if(s.root.hosotope&&s.root.vertices.size===1&&i.vertices.push(G(i.vertices[0],s.root.rootNormals[s.root.hosotope.index-1],s.root.metric)),!(i.vertices.length<e+1)){if(s.root.hosotope){let r;if(s.root.hosotopeVertex?r=l.split("").reverse().reduce((d,g)=>G(d,s.root.rootNormals[s.root.gens.indexOf(g)],s.root.metric),s.root.hosotopeVertex):(s.root.hosotopeVertex=Z(ee(s.root.rootVertices)[s.root.hosotope.index],s.root.metric),r=s.root.hosotopeVertex),c.push({...i,vertices:[i.vertices[0],r]}),c.push({...i,vertices:[r,i.vertices[1]]}),s.root.vertices.size===1){const d=r.map(g=>-g);c.push({...i,vertices:[i.vertices[0],d]}),c.push({...i,vertices:[d,i.vertices[1]]})}}else c.push(i);n.currentWords.delete(f)}}else if(e===2){s.root.hosotopePair=null;for(const[f,l]of n.currentWords){const i=[];for(let g=0;g<n.facet.length;g++){const h=I(s.root,l+n.facet[g]);h&&s.root.vertices.has(h)&&i.push(s.root.vertices.get(h))}if(s.root.hosotope){s.root.vertices.size===1&&i.push(i[0].map(h=>-h));let g;if(s.root.hosotopePair)g=s.root.hosotopePair.map(h=>l.split("").reverse().reduce((u,o)=>G(u,s.root.rootNormals[s.root.gens.indexOf(o)],s.root.metric),h));else{const h=Z(ee(s.root.rootVertices)[s.root.hosotope.index],s.root.metric);s.root.hosotopePair=[h,G(h,s.root.rootNormals[s.root.hosotope.index],s.root.metric)],g=s.root.hosotopePair}i.splice(1,0,g[0]),i.push(g[1]),s.root.vertices.size===1&&(i[3]=i[1].map(h=>-h))}if(i.length<e+1)continue;const r=i.length<n.facet.length;r||n.currentWords.delete(f);const d={word:l,vertices:i,faceIndex:0,faceSize:i.length,partial:r};r?m.push(d):c.push(d)}}else if(e===3)for(const[f,l]of n.currentWords){const i=[];for(let g=0;g<n.facet.length;g++){const h=I(s.root,l+n.facet[g]);h&&s.root.vertices.has(h)&&i.push(s.root.vertices.get(h))}if(i.length<e+1)continue;const r=i.length<n.facet.length||n.partial;r||n.currentWords.delete(f);const d={word:l,vertices:i,faceIndex:0,faceSize:i.length,partial:r};r?m.push(d):c.push(d)}return{objects:c,partials:m}},ie=(e,n=null)=>{if(!e.length)return n||[];if(!n)return n=e[0],ie(e.slice(1),n);const t=n[n.length-1],s=e.find(m=>m[0]===t||m[1]===t);if(!s)return n;const c=e.indexOf(s);return e.splice(c,1),s[0]===t?n.push(s[1]):n.push(s[0]),ie(e,n)},et=(e,n,t,s)=>{const c=[],m=n.children.find(i=>i.key===t.replace("d","")),f=[],l=i=>{i.dimensions===e&&f.push(i.facet),i.children.forEach(l)};l(m),n.children.filter(i=>i.key.includes("s")).forEach(l);for(let i=0;i<f.length;i++){const r=f[i];if(r.length<2)continue;const d=[];for(let h=0;h<r.length;h++){const u=I(s,r[h]);u&&s.vertices.has(u)&&d.push(s.vertices.get(u))}let g=new Array(d[0].length).fill(0);for(let h=0;h<d.length;h++){const u=d[h];g=L(g,u)}g=E(g,1/d.length),c.push(N(g,g))}return Ce(...c)},tt=(e,n,t,s,c,m)=>{var r,d,g;const{space:f}=s.root,l=[],i=[];if(e===0){s.root.dualVertices=s.root.dualVertices||new Map;for(const[h,u]of n.currentWords){const o=[];for(let w=0;w<n.facet.length;w++){const x=I(s.root,u+n.facet[w]);x&&s.root.vertices.has(x)&&o.push(x)}if(o.length<2)continue;const v=o.length<n.facet.length;let a=new Array(t.dimensions).fill(0);for(let w=0;w<o.length;w++){const x=s.root.vertices.get(o[w]);a=L(a,x)}if(a=Z(a,f.metric),f.curvature){let w=0;if(c>=0){let x=1;c>0&&c<t.dimensions-1&&(n.midradius||(n.midradius=et(c,t,m,s.root)),x=n.midradius);const V=U(f.metric,a);for(let j=0;j<o.length;j++){const z=s.root.vertices.get(o[j]);w+=N(V,z)}w/=x*o.length,c===t.dimensions-1&&(w=1/w)}else w=1;a=E(a,f.curvature/w)}const b={word:u,vertices:[a],dual:!0,partial:v},k=`${m}#${u}`;s.root.dualVertices.set(k,{vertex:a,facet:o,partial:v}),v?i.push(b):(l.push(b),n.currentWords.delete(h))}}else if(e===1){if(!((r=s.root.dualVertices)!=null&&r.size))return{objects:l,partials:i};s.root.dualEdges=s.root.dualEdges||new Map;for(const[h,u]of n.currentWords){const o=[];for(let w=0;w<n.facet.length;w++){const x=I(s.root,u+n.facet[w]);x&&s.root.vertices.has(x)&&o.push(x)}if(!o.length)continue;let v=o.length<n.facet.length;const a=[],b=[];for(const[w,{vertex:x,facet:V,partial:j}]of s.root.dualVertices.entries())if(o.every(z=>V.includes(z))&&(a.push(x),b.push(w)),v=v||j,a.length===2)break;if(a.length!==2)continue;const k={word:u,vertices:a,dual:!0,partial:v};s.root.dualEdges.set(`${m}#${u}`,{edge:b,partial:v}),v?i.push(k):(l.push(k),n.currentWords.delete(h))}}else if(e===2){if(!((d=s.root.dualVertices)!=null&&d.size)||!((g=s.root.dualEdges)!=null&&g.size))return{objects:l,partials:i};for(const[h,u]of n.currentWords){const o=[];for(let j=0;j<n.facet.length;j++){const z=I(s.root,u+n.facet[j]);z&&s.root.vertices.has(z)&&o.push(z)}if(o.length<n.facet.length)continue;let v=!1;const a={},b=[];for(const[j,{vertex:z,facet:A,partial:S}]of s.root.dualVertices.entries())(o.every(C=>A.includes(C))||t.dimensions===2)&&(a[j]=z,b.push(j),v=v||S);if(b.length<3)continue;const k=[];for(const{edge:j,partial:z}of s.root.dualEdges.values())b.includes(j[0])&&b.includes(j[1])&&(v=v||z,k.push([...j]));if(k.length<3)continue;const w=[],x=ie(k);if(x.length<4)continue;x[0]===x[x.length-1]&&x.pop();for(let j=0;j<x.length;j++){const z=x[j];w.push(a[z])}const V={word:u,vertices:w,dual:!0,faceSize:w.length,partial:v};v?i.push(V):(l.push(V),n.currentWords.delete(h))}}return{objects:l,partials:i}},nt=(e,n,t)=>{const s=[],c=[],m=[];for(const[f,l]of e.currentWords){let i;if(l===""){const r=ee(t.rootVertices);e.fundamentalVertices=new Map,i=r.map(d=>Z(d,t.metric)),e.hashes={vertex:new Set,edge:new Set,face:new Set},e.fundamentalVertices.set("",i)}else{i=[...e.fundamentalVertices.get(l.slice(1))];const r=e.gens.indexOf(l[0]);for(let d=0;d<i.length;d++)i[d]=G(i[d],t.rootNormals[r],t.metric)}for(let r=0;r<i.length;r++){if(n.dimensions<3){const g=new Array(n.dimensions).fill(0);if(s.push({word:l,vertices:g}),n.dimensions===2){for(let h=0;h<i.length;h++)c.push({word:l,vertices:[g,E(i[h],1e3)]});m.push({word:l,vertices:[g,E(i[r],1e3),E(i[(r+1)%i.length],1e3)]})}}else{const d=ge(i[r]);e.hashes.vertex.has(d)||(s.push({word:l,vertices:[i[r]]}),e.hashes.vertex.add(d));for(let g=r+1;g<i.length;g++){const h=B([i[r],i[g]]);e.hashes.edge.has(h)||(c.push({word:l,vertices:[i[r],i[g]]}),e.hashes.edge.add(h));for(let u=g+1;u<i.length;u++){const o=B([i[r],i[g],i[u]]);e.hashes.face.has(o)||(m.push({word:l,faceSize:3,vertices:[i[r],i[g],i[u]]}),e.hashes.face.add(o))}}}e.fundamentalVertices.set(l,i)}e.currentWords.delete(f)}return[s,c,m]},st=(e,n)=>{e.size=0;for(let t=0;t<2;t++){const s=t===1,c=s?e.partials:e.objects;for(let m=0;m<c.length;m++){const f=c[m];if(!f)continue;const l=[];for(let i=0;i<f.length;i++){const r=f[i],d=r.vertices[0].length,g=r.word.length%2?0:1;if(r.vertices.length===3&&!r.vertices.reduce((o,v)=>L(o,v),new Array(d).fill(0)).every(o=>H(o)<1e-12)){l.push(r);continue}let h=new Array(d).fill(0);for(let o=0;o<r.vertices.length;o++){const v=r.vertices[o];h=L(h,v)}h=E(h,1/r.vertices.length);const u=[];if(n.hosotope&&h.every(o=>H(o)<1e-12)){const o=Ie(r.vertices[0],r.vertices[1]),v=new Array(d).fill(0);o.map((a,b)=>v[b]=a),u.push(v),u.push(v.map(a=>-a));for(let a=3;a<d;a++){const b=[...v];b[2]=0,b[a]=v[2],u.push(b),u.push(b.map(k=>-k))}}else u.push(h);for(let o=0;o<r.vertices.length;o++)for(let v=0;v<u.length;v++){const a={...r,vertices:[r.vertices[(o+g)%r.vertices.length],r.vertices[(o+(1-g))%r.vertices.length],u[v]],faceIndex:o};l.push(a)}}s?e.partials[m]=l:e.objects[m]=l,e.size+=l.length}}},rt=(e,n,t,s,c,m,f,l,i,r)=>{f.root.lasts||(f.root.lasts=new Array(3).fill(0));const d=[];if(c){const g=nt(f.root,e,t);for(let h=0;h<g.length;h++)s[q[h]]?(d.push({start:f.root.lasts[h],size:g[h].length,objects:[g[h]],partials:[]}),f.root.lasts[h]+=g[h].length):d.push(null)}else for(let g=0;g<(r?4:3);g++){if(!f[g]||!r&&!m&&!s[q[g]]){d.push(null);continue}const h={start:f.root.lasts[g],size:0,objects:[],partials:[]};for(let u=0;u<f[g].detail.length;u++){const o=f[g].detail[u],v=n.get(o.key);if(!o.dual&&l.includes(o.key)||!v.compute||!v.currentWords.size){h.objects.push(null),h.partials.push(null);continue}const{objects:a,partials:b}=o.dual?tt(g,v,e,f,i,o.key):pe(g,v,e,f);!r&&(!s[q[g]]||l.includes(o.key))||(h.objects.push(a),h.size+=a.length+b.length,h.partials.push(b))}d.push(h)}return d},ze=(e,n,t,s,c,m,f,l,i,r=[])=>{r.done=!0;let d=!0;for(const u of s.values())if(u.compute&&!u.done){d=!1;break}const g=(u,o,v)=>{if(o.done===!1||o.facet.length===0)return o.gens.includes(u);const a=[],b=[];for(const k of o.facet){const w=I(v,k);if(!w)return null;const x=I(v,u+k);if(!x)return null;a.push(w),b.push(x)}return a.sort((k,w)=>k-w),b.sort((k,w)=>k-w),a.every((k,w)=>k===b[w])},h=u=>{var k;const o=l||f?t.dimensions-u.dimensions-1:u.dimensions;u.children.forEach(h);const v=i[o],a=q[o],b=`${l?"d":f?"f":""}${u.key}`;if(u!=null&&u.new){r[o]||(r[o]={dimensions:o,processing:m[a]?0:void 0,count:0,detail:[],aggregated:[],done:!0});const w=c.eigens.values;if(!s.has(b)){let z="";if(u.dimensions===0)z=t.subgens;else for(let S=0;S<t.gens.length;S++){const C=g(t.gens[S],u,r.root);if(C===null)return;C&&(z+=t.gens[S])}if((k=r.root)!=null&&k.hosotope){if(u.dimensions===1)z=z.replace(r.root.hosotope.gen,"");else if(u.dimensions===2){let S=r.root.coxeter[r.root.hosotope.index].findIndex((P,F)=>F!==r.root.hosotope.index&&P!==2);S<0&&(S=r.root.hosotope.index<r.root.dimensions-1?r.root.hosotope.index+1:0);const C=Object.entries(r.root.transforms).find(([P,F])=>F.includes(S))[0];z=z.replace(C,r.root.hosotope.gen)}}const A={...t,key:b,subgens:z,facet:u.facet,subdimensions:o,mirrors:u.mirrors,compute:v,space:c,...u.dimensions===0&&!f?{rootVertex:c.rootVertex,rootNormals:c.rootNormals,rootVertices:c.rootVertices,metric:c.metric}:{}};s.set(b,A)}const x=s.get(b);u.dimensions===0&&(r.root=x),x.done||(x.limit=v?n:d?1e3:1,a==="edge"&&c.curvature<=0&&(x.limit*=1.75),v?(je(x),w.some(z=>z<=0)?x.count=1/0:x.count=x.cosets.size):w.some(z=>z<=0)?(x.count=1/0,x.done=!0):x.limit&&(x.count=Le(x)));const V=f?u.mirrors.map(()=>0):u.mirrors;r[o].detail.push({key:b,coxeter:u.coxeter,stellation:u.stellation,mirrors:V,dual:l,fundamental:f,count:x.count,done:x.done});const j=r[o].aggregated.find(({coxeter:z,stellation:A,mirrors:S})=>D(z,u.coxeter)&&D(A,u.stellation)&&D(S,V));j?(j.done=j.done&&x.done,j.count+=x.count,j.key+=","+b):r[o].aggregated.push({key:b,coxeter:u.coxeter,stellation:u.stellation,mirrors:V,count:x.count,done:x.done}),m[a]&&x.words&&(r[o].processing+=x.words.size),r[o].count+=x.count,r[o].done=r[o].done&&x.done,r[o].dual=l,r[o].fundamental=f,r.done=r.done&&x.done}};if(t.children.forEach(h),t.dimensions===0){t.currentWords=new Map(e?[[1,""]]:[]),t.facet=[""],t.done=!0;const u=new Map([[1,[0]]]);s.set("v",{...t,subgens:t.subgens,facet:t.facet,subdimensions:t.dimensions,mirrors:t.mirrors,compute:!0,vertices:u}),r.root=r[0]={dimensions:0,processing:1,count:0,detail:[{key:"v",coxeter:t.coxeter,stellation:t.stellation,mirrors:t.mirrors,dual:l,count:0,done:!0}],aggregated:[{key:"v",coxeter:t.coxeter,stellation:t.stellation,mirrors:t.mirrors,dual:l,count:0,done:!0}],vertices:u,done:!0}}else if(t.dimensions===1)t.currentWords=new Map(e?[[1,""]]:[]),t.facet=Array.from(r.root.words.values()),t.done=!0,s.set("e",{...t,subgens:t.subgens,facet:t.facet,subdimensions:t.dimensions,mirrors:t.mirrors,compute:!0}),r[1]={dimensions:1,processing:1,count:0,detail:[{key:"e",coxeter:t.coxeter,stellation:t.stellation,mirrors:t.mirrors,dual:l,count:0,done:!0}],aggregated:[{key:"e",coxeter:t.coxeter,stellation:t.stellation,mirrors:t.mirrors,dual:l,count:0,done:!0}],done:!0};else if(t.dimensions===2){t.currentWords=new Map(e?[[1,""]]:[]);const u=t.gens.split("").every(a=>t.mirrors[t.transforms[a][0]]),o=t.gens.split("").every(a=>t.transforms[a].length===2),v=Array.from(r.root.words.values());t.facet=new Array(v.length);for(let a=0;a<v.length;a++)t.facet[a]=v[o?a:ke(a,t.facet.length,u)];t.done=!0,s.set("f",{...t,subgens:t.subgens,facet:t.facet,subdimensions:t.dimensions,mirrors:t.mirrors,compute:!0}),r[2]={dimensions:2,processing:1,count:0,detail:[{key:"f",coxeter:t.coxeter,stellation:t.stellation,mirrors:t.mirrors,dual:l,count:0,done:!0}],aggregated:[{key:"f",coxeter:t.coxeter,stellation:t.stellation,mirrors:t.mirrors,dual:l,count:0,done:!0}],done:!0}}else t.dimensions===3&&i[3]&&(t.currentWords=new Map([[1,""]]),t.facet=Array.from(r.root.words.values()),t.done=!0,s.set("c",{...t,subgens:t.subgens,facet:t.facet,subdimensions:t.dimensions,mirrors:t.mirrors,compute:!0,partial:!r.root.done}),r[3]={dimensions:3,processing:1,count:0,detail:[{key:"c",coxeter:t.coxeter,stellation:t.stellation,mirrors:t.mirrors,dual:l,count:0,done:!0}],aggregated:[{key:"c",coxeter:t.coxeter,stellation:t.stellation,mirrors:t.mirrors,dual:l,count:0,done:!0}],done:!0});return r.size=f?r.root.words.size:r.root.vertices.size,r};let Q,W;onmessage=({data:{first:e,space:n,dimensions:t,coxeter:s,stellation:c,mirrors:m,ambiance:f,draw:l,batch:i,hidden:r,reciprocation:d,extrarels:g,section:h}})=>{try{e&&(Q=new Map,W=se(t,s,c,m,n,g),self.shape=W);const u=m.length&&m.every(j=>!j),o=m.some(j=>Ee(j)),v=m.some(j=>We(j)),a=u?{[t-1]:!0}:o?{0:!0,1:l.edge||l.face,2:l.face,[t-1]:!0}:h!==null?{0:!0,1:!0,2:l.edge||l.face,3:l.face}:{0:!0,1:l.edge,2:l.face},b=ze(e,i,W,Q,n,l,u,o&&!v,a);v&&ze(e,i,W,Q,n,l,u,o,a,b);let k=rt(W,Q,n,l,u,o,b,r,d,h);h!==null&&(k=Je(b,k,h,l)),k[2]&&!u&&st(k[2],b.root);for(let j=0;j<k.length;j++){const z=k[j];z&&(b.root.lasts[j]+=z.objects.reduce((A,S)=>A+(S?S.length:0),0))}const{infos:w,data:x}=Ye(W.dimensions,k,f,l),V=[...b];V.done=b.done,V.size=b.size,V.root={gens:W.gens,subgens:W.subgens,rels:W.rels,transforms:W.transforms,extrarels:W.extrarels},postMessage({polytope:V,infos:w,data:x},x.flat(1).filter(j=>j).map(j=>j.buffer))}catch(u){postMessage({error:u.message})}}})();
