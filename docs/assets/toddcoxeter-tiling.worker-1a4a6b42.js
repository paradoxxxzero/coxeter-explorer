(function(){"use strict";const L=(t,e=null,l=1,n=!1)=>{if(e===null&&(e=t,t=0),l===0)throw new Error("Step cannot be zero.");if(e<t&&l>0||e>t&&l<0){if(n)return[];l=-l}return new Array(Math.ceil((e-t)/l)).fill().map((s,r)=>t+r*l)},U=(t,e)=>{const l=new Array(t.length);for(let n=0;n<t.length;n++){let s=0;for(let r=0;r<t[0].length;r++)s+=t[n][r]*e[r];l[n]=s}return l},q=(t,e,l)=>{let n=0;for(let s=0;s<t.length;s++)n+=t[s]*e[s]*(s===t.length-1&&l||1);return n},W=(t,e)=>q(t,t,e),J=(t,e,l)=>{t=t.slice();const n=2*q(t,e,l);for(let s=0;s<t.length;s++)t[s]-=n*(l||s!==t.length-1?e[s]:0);return t},K=(t,e)=>{if(t=t.slice(),e===0){for(let n=0;n<t.length;n++)t[n]/=t[t.length-1];return t}const l=(e===-1&&x(t[t.length-1])||1)/$(Y(1e-32,Q(W(t,e))));for(let n=0;n<t.length;n++)t[n]*=l;return t},V=(t,e,l,n)=>{const s=M/t,r=M/e,i=M/l;return Z(M/X(-S(s)*S(i)+R(s)*R(i)*((S(r)-S(n*s)*S(i))/(R(n*s)*R(i)))))},{abs:Q,cos:S,sin:R,tan:ie,cosh:ce,sinh:ge,acos:X,acosh:he,atan:ue,atan2:de,min:pe,max:Y,round:Z,sqrt:$,sign:x,ceil:be,floor:me,log:we,exp:ye,hypot:Ae,pow:_e,PI:M}=Math;function*z(t,e){if(e<0||t.length<e)return;const l=Array.from(Array(e).keys());for(;;){yield l.map(s=>t[s]);let n=e-1;for(;n>=0&&l[n]>=t.length-e+n;)n--;if(n<0)return;for(let s=l[n]+1;n<e;n++,s++)l[n]=s}}const v=(t,e=2)=>Array.from(z(t,e)),w=t=>String.fromCharCode(97+t),ee=t=>t.charCodeAt(0)-97,N=(t,e,l,n,s,r=[])=>{const i=[];for(let a=0;a<t;a++)r.includes(a)||i.push(w(a).repeat(2));for(let a=1;a<t;a++)for(let o=0;o<a;o++)!r.includes(a)&&!r.includes(o)&&e[a][o]>1&&i.push((w(o)+w(a)).repeat(e[a][o]));if(!r.length&&l&&!l.every(a=>a.every(o=>o===1))&&s>0){if(t===4&&l[0][1]>1!=l[2][3]>1&&e[0][1]>3&&e[2][3]>3)l[0][1]>1&&i.push("abcdcb".repeat(V(e[0][1],e[1][2],e[0][2],l[0][1]))),l[2][3]>1&&i.push("abcdcb".repeat(V(e[2][3],e[1][2],e[1][3],l[2][3])));else for(let a=1;a<t;a++)for(let o=0;o<a;o++)if(l[o][a]>1){if(o+2<t){const u=V(e[o+1][a+1],e[o][a],e[o][a+1],l[o][a]);i.push((w(o)+w(a)+w(o+2)+w(a)).repeat(u))}if(o-1>=0){const u=V(e[o-1][a-1],e[o][a],e[o-1][a],l[o][a]);i.push((w(o)+w(a)+w(o)+w(o-1)).repeat(u))}}}return i},G=t=>t!==""&&t!=="x",te=t=>isNaN(t)?1:+t,I=(t,e=[])=>t.map((l,n)=>e.includes(n)?"":w(n)).join(""),B=(t,e=[])=>t.map((l,n)=>e.includes(n)||l?"":w(n)).join(""),ne=(t,e,l,n,s)=>{const r=n.map((u,b)=>G(u)?null:b).filter(u=>u),i=N(t,e,l,n,s,r),a=I(n,r),o=B(n,r);return{gens:a,subgens:o,rels:i}},le=(t,e,l,n,s)=>{const r=n.map((u,b)=>G(u)?null:b).filter(u=>u),i=N(t,e,l,n,s,r),a=I(n,r),o=[];for(let u=0;u<n.length;u++)if(n[u]){let b=w(u);for(let d=0;d<t;d++)e[u][d]===2&&!n[d]&&(b+=w(d));o.push({gens:a,subgens:b,rels:i,target:w(u)})}return o},se=(t,e,l,n,s)=>{const r=n.map((b,d)=>G(b)?null:d).filter(b=>b),i=N(t,e,l,n,s,r),a=I(n,r),o=[],u=v(L(t),t-2);for(let b=0;b<u.length;b++){const d=Array.from(new Set(u[b].concat(r))),k=N(t,e,l,n,s,d);let p=I(n,d);const y=B(n,d),g=E({gens:p,subgens:y,rels:k,cosets:{normal:[],reverse:[]},rows:[],words:[],limit:1e3}).words;if(g.length>2){let f="";for(let c=0;c<t;c++)d.includes(c)||(f+=w(c));for(let c=0;c<t;c++)if(!n[c]){let h=!0;for(let m=0;m<t;m++)if(!d.includes(m)&&e[m][c]!==2){h=!1;break}h&&(f+=w(c))}o.push({gens:a,subgens:f,rels:i,face:g,double:n.filter((c,h)=>!d.includes(h)).every(c=>!!c)})}}return o},re=(t,e)=>{if(e.left===e.right)return!1;for(;e.left!==e.right;){const l=t.normal[e.left_coset][e.rel[e.left]];if(l===void 0)break;e.left++,e.left_coset=l}for(;e.left!==e.right;){const l=t.reverse[e.right_target][e.rel[e.right]];if(l===void 0)break;e.right--,e.right_target=l}return e.left===e.right?(t.normal[e.left_coset][e.rel[e.right]]=e.right_target,t.reverse[e.right_target][e.rel[e.right]]=e.left_coset,!0):!1},E=t=>{const{gens:e,subgens:l,rels:n,cosets:s,rows:r,words:i,limit:a}=t,o=e.length,u=n.map(p=>[...p].map(y=>e.indexOf(y))),b=l.split("").map(p=>e.indexOf(p));if(s.normal.length===0){s.normal.push(new Array(o).fill()),s.reverse.push(new Array(o).fill());for(let p=0;p<b.length;p++)s.normal[0][b[p]]=0,s.reverse[0][b[p]]=0}for(r.length===0&&r.push(...u.map(p=>({rel:p,left:0,right:p.length-1,left_coset:0,right_target:0})));r.length&&s.normal.length<a;){for(;;){let g=!1;for(let f=r.length-1;f>=0;f--)re(s,r[f])&&(g=!0,r.splice(f,1));if(!g)break}const p=s.normal.length;let y=!1;for(let g=0;g<s.normal.length;g++){const f=s.normal[g];for(let c=0;c<f.length;c++){let h=f[c];if(h===void 0){h=s.normal.length,s.normal.push(new Array(o).fill()),s.reverse.push(new Array(o).fill()),s.normal[g][c]=h,s.reverse[h][c]=g,r.push(...u.map(m=>({rel:m,left:0,right:m.length-1,left_coset:p,right_target:p}))),y=!0;break}}if(y)break}}r.length||(t.done=!0),i.length===0&&(i[0]="");let d=!0,k=s.normal.length;for(;fe(s.normal.length,i)&&d&&--k;){d=!1;for(let p=0;p<i.length;p++){if(i[p]===void 0)continue;const y=s.normal[p];for(let g=0;g<y.length;g++){const f=y[g];f===void 0||i[f]!==void 0||(i[f]=i[p]+e[g],d=!0)}}}return d||console.warn("Hole in the cosets"),k===0&&console.warn("Max iterations reached"),{cosets:s,rows:r,words:i}},fe=(t,e)=>{for(let l=0;l<t;l++)if(e[l]===void 0)return!0;return!1};let j=null,O=null,T=null;const oe=(t,e,l,n,s)=>{const r=()=>({cosets:{normal:[],reverse:[]},rows:[],words:[],done:!1,lastDrawn:0});j={...ne(t,e,l,n,s),...r()},O=le(t,e,l,n,s).map(i=>({...i,...r()})),T=se(t,e,l,n,s).map(i=>({...i,...r(),toRetry:new Set}))},ae=(t,e)=>{const{rootVertex:l,rootNormals:n,curvature:s}=t;let r=l;for(let i=0;i<e.length;i++)r=J(r,n[e.charCodeAt(i)-97],s);return r},C=(t,e)=>{for(let l=0;l<t.length;l++){const n=ee(t[l]),s=j.cosets.normal[e][n];if(s===void 0)return;e=s}return e};onmessage=({data:{order:t,curvature:e,rootNormals:l,coxeter:n,stellation:s,mirrors:r,rootVertices:i,dimensions:a,uuid:o}})=>{t===0&&oe(a,n,s,r,e);const u=K(U(i,r.map(d=>te(d))),e),b=(t+1)*(e>0?500:100);try{let d=[],k=[],p=[],y=[];if(!j.done){j.limit=b,E(j);for(let g=j.lastDrawn;g<j.words.length;g++){const f=j.words[g];if(f===void 0){d.push({vertex:new Array(a).fill(NaN),word:""});continue}const c=ae({rootVertex:u,rootNormals:l,curvature:e},f);d.push({vertex:c,word:f,i:g}),j.lastDrawn=g+1}}for(let g=0;g<O.length;g++){const f=O[g];f.done||(f.limit=b*(e>0?1:e<0?1.5:3),E(f));const c=C(f.target,0);for(let h=f.lastDrawn;h<f.words.length;h++){const m=f.words[h];if(m===void 0)continue;const A=C(m,0),_=C(m,c);if(A===void 0||_===void 0){f.lastDrawn=h;break}k.push({start:A,end:_,word:m}),f.lastDrawn=h+1}}for(let g=0;g<T.length;g++){const f=T[g];f.done||(f.limit=b*(e>0?1:e<0?1.5:2.5),E(f));const c=[];for(let h=0;h<f.face.length;h++)c.push(C(f.face[h],0));for(const h of f.toRetry){const m=f.words[h],A=[];for(let _=0;_<c.length;_++){const P=c[F(_,c.length,f.double)];if(P===void 0)continue;const D=C(m,P);D!==void 0&&A.push(D)}A.length===c.length?(p.push({vertices:A,word:m,len:c.length}),f.toRetry.delete(h)):y.push({vertices:A,word:m,len:c.length})}for(let h=f.lastDrawn;h<f.words.length;h++){let m=!1;const A=f.words[h],_=[];for(let P=0;P<c.length;P++){const D=c[F(P,c.length,f.double)];if(D===void 0){m=!0;continue}const H=C(A,D);if(H===void 0){m=!0;continue}_.push(H)}m?(y.push({vertices:_,word:A,len:c.length}),f.toRetry.add(h)):p.push({vertices:_,word:A,len:c.length}),f.lastDrawn=h+1}}postMessage({vertices:d,edges:k,faces:p,partials:y,order:t,uuid:o})}catch(d){postMessage({error:d.message,uuid:o})}};const F=(t,e,l=!1)=>{if(l){const n=t>0?1-t%2:0;return t>=e/2+n?2*(e-t)-1+n:2*t-n}return t>=e/2?2*(e-t)-1:2*t}})();
